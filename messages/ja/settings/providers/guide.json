{
  "after": "フィルタ後:",
  "before": "フィルタ前:",
  "bestPracticesConcurrent": "• 同時実行制御: プロバイダー API 制限に合わせてセッションの同時数を設定",
  "bestPracticesCost": "• コスト乗数: 公式=1.0、自前ホストは 0.8-1.2 を設定可能",
  "bestPracticesLimit": "• 上限設定: 予算に合わせて 5h / 7d / 30d の上限を設定",
  "bestPracticesPriority": "• 優先度設定: メインのプロバイダー=0、バックアップ=1-3",
  "bestPracticesTitle": "ベストプラクティス",
  "bestPracticesWeight": "• 重み設定: 容量に応じて重みを設定 (容量が大きいほど重みも大きい)",
  "circuitBreaker": "サーキットブレーカーチェック",
  "circuitBreakerOpen": "Aはフィルタされました、残り：B、C、D",
  "circuitBreakerRecovery": "Aは60秒後に半開状態に自動復帰します",
  "circuitBreakerRecovery5h": "5時間スライディングウィンドウ後に自動復帰",
  "costOptimize": "2. コスト最適化: 同一優先度内では、コスト乗数が低いほど選択確率が高くなります",
  "costSort": "コストベースのソートフォールバック",
  "costSortExample": "すべてのプロバイダー: A (default)、B (premium)、C (premium)、D (economy)",
  "costSortProb": "より安いCがより高い選択確率を持ちます",
  "costSortResult": "ソート後: C (0.8x)、A (1.0x)",
  "decision": "判断:",
  "group": "ユーザーグループフィルタリング",
  "groupDesc": "ユーザーがプロバイダーグループを指定した場合、システムはそのグループから優先的に選択します",
  "groupDowngrade": "警告をログに記録し、グローバルプロバイダープールから選択",
  "groupExample": "ユーザーは providerGroup = 'premium' を設定しました",
  "groupFallback": "グループに利用可能なプロバイダーがない場合は、すべてのプロバイダーにフォールバック",
  "groupFiltered": "AとCのみから選択、BとDはフィルタされます",
  "groupUnavailable": "ユーザーグループ'vip'のすべてのプロバイダーが無効または制限超過です",
  "health": "健全性フィルタリング (サーキットブレーカー + レート制限)",
  "healthCheck": "Bが有効で健全かをチェック",
  "healthCheckAmountLimit": "支出上限をチェック (5h, 7d, 30d)",
  "healthCheckAmountLimitExample": "プロバイダー B の 5h 上限 $10、消費 $9.8",
  "healthCheckCircuit": "プロバイダー A 5回失敗、サーキットブレーカー: オープン",
  "healthCheckConcurrent": "現在のアクティブセッション数が上限を超えていないかをチェック",
  "healthCheckConcurrentExample": "プロバイダー C 同時制限 2、現在アクティブ 2 セッション",
  "healthFilter": "3. ヘルスフィルタ: サーキットブレーカー中または上限超過のプロバイダーを自動でスキップします",
  "healthFiltered": "B を除外 (上限に接近)、残り: C、D",
  "healthFiltered2": "C を除外 (満杯)、残り: D",
  "history": "リクエスト履歴をチェック",
  "historyDesc": "この API キーが過去 10 秒間に使用したプロバイダーをクエリします",
  "priority": "優先度階層化",
  "priorityExample": "異なる優先度を持つ4つのプロバイダーが有効です",
  "priorityFirst": "1. 優先度優先: 最優先 (数値が最小) のプロバイダーからのみ選択します",
  "priorityResult": "最優先 (0) のプロバイダーに絞り込み: A、C",
  "priorityStep": "システムは優先度でフィルタし、最高優先度のプロバイダーのみを選択します",
  "randomResult": "最終的に C がランダムに選択されました",
  "randomSelect": "加重ランダム",
  "reset": "サーキットブレーカーを手動リセット",
  "resetSuccess": "サーキットブレーカーがリセットされました",
  "scenario1Desc": "システムはまず優先度でフィルタし、最優先プロバイダーのみから選択します",
  "scenario1Step1": "初期状態",
  "scenario1Step1After": "最優先 (0) のプロバイダーに絞り込み: A、C",
  "scenario1Step1Before": "プロバイダー A (優先度 0)、B (優先度 1)、C (優先度 0)、D (優先度 2)",
  "scenario1Step1Decision": "A と C のみから選択し、B と D は除外されます",
  "scenario1Step1Desc": "優先度が異なる4つのプロバイダーが有効です",
  "scenario1Step2": "コストソート",
  "scenario1Step2After": "ソート後: C (0.8x)、A (1.0x)",
  "scenario1Step2Before": "A (コスト 1.0x)、C (コスト 0.8x)",
  "scenario1Step2Decision": "より安い C の方が選択確率が高くなります",
  "scenario1Step2Desc": "同一優先度内では、コスト乗数の低い順にソートします",
  "scenario1Step3": "加重ランダム",
  "scenario1Step3After": "C の確率 75%、A の確率 25%",
  "scenario1Step3Before": "C (重み 3)、A (重み 1)",
  "scenario1Step3Decision": "最終的に C がランダムに選択されました",
  "scenario1Step3Desc": "重みでランダム選択し、重みが大きいほど確率が高くなります",
  "scenario1Title": "優先度階層化",
  "scenario2Desc": "ユーザーがプロバイダーグループを指定した場合、システムはそのグループから優先的に選択します",
  "scenario2Step1": "ユーザーグループを確認",
  "scenario2Step1After": "'premium' グループに絞り込み: B、C",
  "scenario2Step1Before": "すべてのプロバイダー: A (default)、B (premium)、C (premium)、D (economy)",
  "scenario2Step1Decision": "B と C のみから選択します",
  "scenario2Step1Desc": "ユーザーは providerGroup = 'premium' を設定しました",
  "scenario2Step2": "グループフォールバック",
  "scenario2Step2After": "有効なすべてのプロバイダーにフォールバック: A、B、C、D",
  "scenario2Step2Before": "ユーザーグループ'vip'のすべてのプロバイダーが無効または制限超過です",
  "scenario2Step2Decision": "警告をログに記録し、グローバルプロバイダープールから選択します",
  "scenario2Step2Desc": "グループに利用可能なプロバイダーがない場合は、すべてのプロバイダーにフォールバック",
  "scenario2Title": "ユーザーグループフィルタリング",
  "scenario3Desc": "システムはサーキットブレーカー中または上限超過のプロバイダーを自動で除外します",
  "scenario3Step1": "サーキットブレーカーチェック",
  "scenario3Step1After": "A を除外、残り: B、C、D",
  "scenario3Step1Before": "プロバイダー A 5回失敗、サーキットブレーカー: オープン",
  "scenario3Step1Decision": "A は 60 秒後に半開状態へ自動復帰します",
  "scenario3Step1Desc": "5回連続で失敗するとサーキットブレーカーがオープンし、60秒間利用できません",
  "scenario3Step2": "金額レート制限",
  "scenario3Step2After": "B を除外 (上限に接近)、残り: C、D",
  "scenario3Step2Before": "プロバイダー B の 5h 上限 $10、消費 $9.8",
  "scenario3Step2Decision": "5時間スライディングウィンドウ後に自動復帰",
  "scenario3Step2Desc": "支出が上限 (5h, 7d, 30d) を超えていないか確認します",
  "scenario3Step3": "同時セッション制限",
  "scenario3Step3After": "C を除外 (満杯)、残り: D",
  "scenario3Step3Before": "プロバイダー C 同時制限 2、現在アクティブ 2 セッション",
  "scenario3Step3Decision": "セッション期限切れ後に自動解放 (5分)",
  "scenario3Step3Desc": "現在のアクティブセッション数が設定された同時上限を超えていないか確認します",
  "scenario3Title": "ヘルスフィルタ (サーキットブレーカー + レート制限)",
  "scenario4Desc": "連続したチャットでは Claude のコンテキストキャッシュを活用し、同じプロバイダーを優先して再利用します",
  "scenario4Step1": "リクエスト履歴を確認",
  "scenario4Step1After": "B が有効で健全かをチェック",
  "scenario4Step1Before": "最後のリクエストはプロバイダー B を使用しました",
  "scenario4Step1Decision": "B は利用可能なら直接再利用し、ランダム選択をスキップします",
  "scenario4Step1Desc": "この API キーが過去 10 秒間に使用したプロバイダーをクエリします",
  "scenario4Step2": "再利用の無効化",
  "scenario4Step2After": "通常の選択フローに戻ります",
  "scenario4Step2Before": "前回使用したプロバイダー B は無効またはサーキットオープン状態です",
  "scenario4Step2Decision": "他の利用可能なプロバイダーから選択",
  "scenario4Step2Desc": "前回使用したプロバイダーが利用できない場合は再選択します",
  "scenario4Title": "セッション再利用メカニズム",
  "scenariosTitle": "インタラクティブなシナリオデモ",
  "session": "セッション再利用メカニズム",
  "sessionDesc": "前回使用したプロバイダーが利用できない場合は再選択します",
  "sessionExample": "最後のリクエストはプロバイダー B を使用しました",
  "sessionExpired": "セッションは期限切れ (5分) 後に自動的に解放されます",
  "sessionFallback": "他の利用可能なプロバイダーから選択",
  "sessionLastUsed": "B は利用可能、直接再利用、ランダム選択をスキップ",
  "sessionReuse": "4. セッション再利用: 連続したチャットでは同じプロバイダーを再利用し、コンテキストコストを節約します",
  "sessionUnavailable": "前回使用したプロバイダー B は無効またはサーキットオープン状態です",
  "step": "ステップ",
  "title": "基本原則",
  "weight": "重みに基づく加重ランダム選択",
  "weightCalc": "Cは75％の選択確率、Aは25％",
  "weightExample": "C (重み 3)、A (重み 1)"
}
