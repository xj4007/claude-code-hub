{
  "clientVersions": {
    "description": "クライアントバージョン要件を管理し、ユーザーが最新の安定版を使用していることを確認します。VSCodeとCLIは個別に管理されます。",
    "empty": {
      "description": "過去7日間に認識可能なクライアントを使用したアクティブユーザーがいません",
      "title": "クライアントデータなし"
    },
    "features": {
      "activeWindow": "アクティブウィンドウ：",
      "activeWindowDesc": "過去7日間にリクエストがあったユーザーのみを集計",
      "autoDetect": "システムは各クライアントの最新安定版（GAバージョン）を自動検出します",
      "blockOldVersion": "旧バージョンを使用するユーザーはHTTP 400エラーを受信し、サービスを継続使用できません",
      "errorMessage": "エラーメッセージには現在のバージョンとアップグレード必要バージョン番号が含まれます",
      "gaRule": "判定ルール：",
      "gaRuleDesc": "1人以上のユーザーが使用しているバージョンをGAバージョンとみなします",
      "recommendation": "推奨方法：",
      "recommendationDesc": "まず下記のバージョン分布を確認し、新バージョンが安定していることを確認してから有効にしてください。",
      "title": "機能説明",
      "whatHappens": "有効化後の動作："
    },
    "section": {
      "distribution": {
        "description": "過去7日間のアクティブユーザーのクライアントバージョン情報を表示します。各クライアントタイプごとにGAバージョンを独立して集計します。",
        "title": "クライアントバージョン分布"
      },
      "settings": {
        "description": "有効にすると、システムはクライアントバージョンを自動的に検出し、旧バージョンユーザーのリクエストをブロックします。",
        "title": "アップグレードリマインダー設定"
      }
    },
    "table": {
      "currentGA": "現在のGAバージョン：",
      "internalType": "内部タイプ：",
      "lastActive": "最終アクティブ時間",
      "latest": "最新",
      "needsUpgrade": "アップグレード必要",
      "noUsers": "ユーザーデータなし",
      "status": "ステータス",
      "unknown": "不明",
      "user": "ユーザー",
      "usersCount": "{count}名のユーザー",
      "version": "現在のバージョン"
    },
    "title": "クライアント更新リマインダー",
    "toggle": {
      "description": "有効にすると、システムはクライアントバージョンを自動的に検出し、古いバージョンをブロックします。",
      "disableSuccess": "クライアントバージョンチェックが無効になりました",
      "enable": "クライアントバージョンチェックを有効にする",
      "enableSuccess": "クライアントバージョンチェックが有効になりました",
      "toggleFailed": "トグルに失敗しました"
    }
  },
  "common": {
    "cancel": "キャンセル",
    "completed": "完了",
    "confirm": "確認",
    "copied": "キーをクリップボードにコピーしました",
    "copy": "コピー",
    "copyFailed": "コピーに失敗しました",
    "create": "作成",
    "creating": "作成中...",
    "delete": "削除",
    "disabled": "無効",
    "edit": "編集",
    "empty": "結果が見つかりません",
    "enabled": "有効",
    "error": "不明なエラー",
    "failed": "失敗",
    "loading": "読み込み中...",
    "none": "なし（このバージョンを使用しているユーザーなし）",
    "refresh": "更新",
    "reset": "リセット",
    "save": "保存",
    "saving": "保存中...",
    "submit": "送信",
    "success": "成功",
    "test": "テスト",
    "testing": "テスト中...",
    "unlimited": "無制限",
    "unlimited_desc": "無制限",
    "update": "更新",
    "updating": "更新中..."
  },
  "config": {
    "autoCleanup": "ログ自動クリーンアップ",
    "autoCleanupDesc": "スケジュールに従って履歴ログを自動的にクリーンアップし、データベース容量を解放します。",
    "description": "システムの基本パラメータを管理し、サイト表示と統計動作に影響します。",
    "section": {
      "siteParams": {
        "title": "サイトパラメータ",
        "description": "サイトタイトル、通貨表示単位、ダッシュボード統計表示ポリシーを設定します。"
      },
      "autoCleanup": {
        "title": "ログ自動クリーンアップ",
        "description": "スケジュールに従って履歴ログを自動的にクリーンアップし、データベース容量を解放します。"
      }
    },
    "form": {
      "allowGlobalView": "グローバル使用量表示を許可",
      "allowGlobalViewDesc": "無効にすると、一般ユーザーはダッシュボードで自分のキーの使用統計のみを表示できます。",
      "verboseProviderError": "詳細なプロバイダーエラー",
      "verboseProviderErrorDesc": "有効にすると、すべてのプロバイダーが利用不可の場合に詳細なエラーメッセージ（プロバイダー数、レート制限の理由など）を返します。無効の場合は簡潔なエラーコードのみを返します。",
      "cleanupSchedule": "クリーンアップスケジュール",
      "cleanupScheduleDesc": "自動クリーンアップの実行スケジュールを選択します",
      "configUpdated": "システム設定が更新されました。ページが更新され、通貨表示の変更が適用されます。",
      "currencyDisplay": "通貨表示単位",
      "currencyDisplayPlaceholder": "通貨単位を選択",
      "currencyDisplayDesc": "変更後、システムのすべてのページとAPIインターフェースは対応する通貨記号を使用します（記号のみ、為替レート変換なし）。",
      "keepDays": "保持日数",
      "keepDaysDesc": "指定した日数より古いログをクリーンアップします",
      "saveFailed": "保存に失敗しました",
      "saveSuccess": "正常に保存されました",
      "saveError": "保存に失敗しました",
      "saveSettings": "設定を保存",
      "siteTitle": "サイトタイトル",
      "siteTitlePlaceholder": "例：Claude Code Hub",
      "siteTitleRequired": "サイトタイトルは空にできません",
      "siteTitleDesc": "ブラウザタブのタイトルとシステムのデフォルト表示名を設定するために使用されます。",
      "enableAutoCleanup": "自動クリーンアップを有効にする",
      "enableAutoCleanupDesc": "スケジュールに従って履歴ログを自動的にクリーンアップします",
      "cleanupRetentionDays": "保持日数",
      "cleanupRetentionDaysRequired": "保持日数 *",
      "cleanupRetentionDaysPlaceholder": "30",
      "cleanupRetentionDaysDesc": "この日数を超えるログは自動的にクリーンアップされます（範囲：1-365日）",
      "cleanupScheduleLabel": "実行時間（Cron）",
      "cleanupScheduleRequired": "実行時間（Cron）*",
      "cleanupSchedulePlaceholder": "0 2 * * *",
      "cleanupScheduleCronDesc": "Cron式、デフォルト：0 2 * * *（毎日午前2時）",
      "cleanupScheduleCronExample": "例：0 3 * * 0（毎週日曜日午前3時）",
      "cleanupBatchSize": "バッチサイズ",
      "cleanupBatchSizeRequired": "バッチサイズ *",
      "cleanupBatchSizePlaceholder": "10000",
      "cleanupBatchSizeDesc": "バッチごとに削除するレコード数（範囲：1000-100000、推奨10000）",
      "saveConfig": "設定を保存",
      "autoCleanupSaved": "自動クリーンアップ設定が保存されました",
      "currencies": {
        "USD": "$ 米ドル (USD)",
        "CNY": "¥ 人民元 (CNY)",
        "EUR": "€ ユーロ (EUR)",
        "JPY": "¥ 日本円 (JPY)",
        "GBP": "£ 英ポンド (GBP)",
        "HKD": "HK$ 香港ドル (HKD)",
        "TWD": "NT$ 新台湾ドル (TWD)",
        "KRW": "₩ 韓国ウォン (KRW)",
        "SGD": "S$ シンガポールドル (SGD)"
      },
      "billingModelSource": "課金モデルソース",
      "billingModelSourcePlaceholder": "課金モデルソースを選択",
      "billingModelSourceDesc": "モデルリダイレクト時に課金に使用するモデルを設定します。「リダイレクト前」はユーザーがリクエストした元のモデル、「リダイレクト後」は実際に呼び出されたモデルを使用します。",
      "billingModelSourceOptions": {
        "original": "リダイレクト前（元のモデル）",
        "redirected": "リダイレクト後（実際のモデル）"
      }
    },
    "siteSettings": "サイトパラメータ",
    "siteSettingsDesc": "サイトタイトル、通貨表示単位、ダッシュボード統計表示方針を設定します。",
    "title": "基本設定"
  },
  "data": {
    "cleanup": {
      "rangeLabel": "クリーンアップ範囲",
      "range": {
        "7days": "1週間前のログ（7日）",
        "30days": "1ヶ月前のログ（30日）",
        "90days": "3ヶ月前のログ（90日）",
        "180days": "6ヶ月前のログ（180日）"
      },
      "rangeDescription": {
        "7days": "1週間前",
        "30days": "1ヶ月前",
        "90days": "3ヶ月前",
        "180days": "6ヶ月前",
        "default": "{days}日前"
      },
      "willClean": "{range}のすべてのログレコードをクリーンアップします",
      "button": "ログをクリーンアップ",
      "confirmTitle": "ログクリーンアップの確認",
      "confirmWarning": "この操作は{range}のすべてのログレコードを完全に削除し、復元できません。",
      "previewLoading": "集計中...",
      "previewCount": "{count}件のログレコードを削除します",
      "previewError": "プレビュー情報を取得できません",
      "statisticsRetained": "✓ 統計データは保持されます（トレンド分析用）",
      "logsDeleted": "✗ ログ詳細は削除されます（リクエスト/レスポンス内容、エラー情報など）",
      "backupRecommendation": "推奨：クリーンアップ前にデータベースバックアップをエクスポートして、データ復元が必要な場合に備えてください。",
      "cancel": "キャンセル",
      "confirm": "クリーンアップを確認",
      "cleaning": "クリーンアップ中...",
      "successMessage": "{count}件のログレコードをクリーンアップしました（{batches}バッチ、所要時間{duration}秒）",
      "failed": "クリーンアップ失敗",
      "error": "ログのクリーンアップに失敗しました",
      "descriptionWarning": "履歴ログデータをクリーンアップしてデータベースストレージを解放します。注：統計データは保持されますが、ログ詳細は完全に削除されます。"
    },
    "description": "データベースのバックアップと復元を管理し、完全なインポート/エクスポートとログクリーンアップをサポートします。",
    "export": {
      "button": "データベースをエクスポート",
      "exporting": "エクスポート中...",
      "successMessage": "データベースのエクスポートに成功しました！",
      "failed": "エクスポート失敗",
      "error": "データベースのエクスポートに失敗しました",
      "descriptionFull": "完全なデータベースバックアップファイル（.dump形式）をエクスポートし、データ移行または復旧に使用できます。バックアップはPostgreSQL custom formatを使用し、自動圧縮され、異なるデータベースバージョンと互換性があります。"
    },
    "guide": {
      "title": "使用説明と注意事項",
      "items": {
        "cleanup": {
          "title": "ログクリーンアップ",
          "description": "履歴ログを物理的に削除します（取り消せません）。統計テーブルは保持されます。クリーンアップ前にデータベースバックアップをエクスポートすることをお勧めします。"
        },
        "format": {
          "title": "バックアップ形式",
          "description": "PostgreSQL custom format（.dump）を使用し、自動圧縮で異なるデータベースバージョンと互換性があります。"
        },
        "overwrite": {
          "title": "上書きモード",
          "description": "インポート前にすべての既存データを削除します。完全復元に最適です。"
        },
        "merge": {
          "title": "統合モード",
          "description": "既存データを保持し、バックアップからのデータを挿入しようとします。主キーの競合がインポート失敗を引き起こす可能性があります。"
        },
        "safety": {
          "title": "セキュリティ推奨",
          "description": "インポート前に現在のデータベースをバックアップとしてエクスポートすることをお勧めします。"
        },
        "environment": {
          "title": "環境要件",
          "description": "Docker Composeデプロイメントが必要です。ローカル開発環境ではサポートされない可能性があります。"
        }
      }
    },
    "import": {
      "selectFileLabel": "バックアップファイルを選択",
      "fileSelected": "選択済み：{name}（{size} MB）",
      "fileError": ".dump形式のバックアップファイルを選択してください",
      "noFileSelected": "最初にバックアップファイルを選択してください",
      "cleanFirstLabel": "既存データをクリア（上書きモード）",
      "cleanFirstDescription": "インポート前にすべての既存データを削除し、データベースがバックアップと完全に一致するようにします。チェックしない場合、データのマージを試みますが、主キーの競合により失敗する可能性があります。",
      "button": "データベースをインポート",
      "importing": "インポート中...",
      "progressTitle": "インポート進行状況",
      "confirmTitle": "データベースインポートの確認",
      "confirmOverwrite": "「上書きモード」を選択しました。これにより、すべての既存データが削除された後、バックアップがインポートされます。",
      "confirmMerge": "「マージモード」を選択しました。これにより、既存データを保持しながらバックアップのインポートを試みます。",
      "warningOverwrite": "⚠️ 警告：この操作は元に戻せません。すべての現在のデータが完全に削除されます！",
      "warningMerge": "⚠️ 注意：主キーの競合が存在する場合、インポートが失敗する可能性があります。",
      "backupFile": "バックアップファイル：",
      "backupRecommendation": "この操作を実行する前に、現在のデータベースをバックアップとしてエクスポートすることをお勧めします。",
      "cancel": "キャンセル",
      "confirm": "インポートを確認",
      "successMessage": "データインポート完了！",
      "failedMessage": "データインポート失敗、詳細ログを確認してください",
      "error": "データベースのインポートに失敗しました",
      "streamError": "レスポンスストリームを読み取れません",
      "errorUnknown": "不明なエラー",
      "descriptionFull": "バックアップファイルからデータベースを復元します。PostgreSQL custom format（.dump）形式のバックアップファイルをサポートします。"
    },
    "status": {
      "loading": "読み込み中...",
      "error": "データベースステータスの取得に失敗しました",
      "retry": "再試行",
      "connected": "データベース接続正常",
      "unavailable": "データベース利用不可",
      "tables": "{count} テーブル"
    },
    "title": "データ管理",
    "section": {
      "status": {
        "title": "データベースステータス",
        "description": "現在のデータベース接続状態と基本情報を表示します。"
      },
      "cleanup": {
        "title": "ログクリーンアップ",
        "description": "履歴ログデータをクリーンアップしてデータベースストレージを解放します。注：統計データは保持されますが、ログ詳細は完全に削除されます。"
      },
      "export": {
        "title": "データエクスポート",
        "description": "完全なデータベースバックアップファイル（.dump形式）をエクスポートし、データ移行または復旧に使用できます。"
      },
      "import": {
        "title": "データインポート",
        "description": "バックアップファイルからデータベースを復元します。PostgreSQL custom format（.dump）形式のバックアップファイルをサポートします。"
      }
    }
  },
  "errors": {
    "saveSuccess": "保存に成功しました",
    "saveFailed": "保存に失敗しました",
    "saveFailed_error": "設定の保存に失敗しました",
    "addSuccess": "追加に成功しました",
    "addFailed": "プロバイダーの追加に失敗しました",
    "editSuccess": "更新に成功しました",
    "editFailed": "プロバイダーの更新に失敗しました",
    "deleteSuccess": "削除に成功しました",
    "deleteFailed": "プロバイダーの削除に失敗しました",
    "syncSuccess": "同期に成功しました",
    "syncFailed": "同期に失敗しました",
    "testFailed": "テストに失敗しました",
    "testFailedRetry": "テストに失敗しました。再試行してください",
    "loadFailed": "通知設定の読み込みに失敗しました",
    "unknownError": "操作中に例外が発生しました"
  },
  "logs": {
    "description": "システムログレベルを動的に調整してロギング詳細度をリアルタイムで制御します。",
    "subtitle": "ログレベルコントロール",
    "subtitleDesc": "変更はすぐに有効になります、再起動不要。本番環境でのトラブルシューティングに便利です。",
    "section": {
      "title": "ログレベルコントロール",
      "description": "変更はすぐに有効になります、サービス再起動不要。"
    },
    "levels": {
      "fatal": {
        "label": "Fatal",
        "description": "致命的エラーのみ"
      },
      "error": {
        "label": "Error",
        "description": "エラーメッセージ"
      },
      "warn": {
        "label": "Warn",
        "description": "警告 + エラー"
      },
      "info": {
        "label": "Info",
        "description": "主要なビジネスイベント + 警告 + エラー（本番環境推奨）"
      },
      "debug": {
        "label": "Debug",
        "description": "デバッグ情報 + 全レベル（開発環境推奨）"
      },
      "trace": {
        "label": "Trace",
        "description": "非常に詳細なトレース + 全レベル"
      }
    },
    "form": {
      "currentLevel": "現在のログレベル",
      "selectLevel": "ログレベルを選択",
      "save": "設定を保存",
      "saving": "保存中...",
      "success": "ログレベルを設定しました: {level}",
      "failed": "設定に失敗しました",
      "failedError": "ログレベルの設定に失敗しました",
      "fetchFailed": "ログレベルの取得に失敗しました",
      "effectiveImmediately": "ログレベルの変更はすぐに有効になります、サービス再起動不要。",
      "levelGuideTitle": "ログレベルガイド",
      "levelGuideFatal": "Fatal/Error: エラーのみ表示、最小限のログ、高負荷本番環境に適しています",
      "levelGuideWarn": "Warn: 警告（レート制限、サーキットブレーカー開放など）+ エラーを含む",
      "levelGuideInfo": "Info（本番環境推奨）: 主要なビジネスイベント（プロバイダー選択、セッション再利用、価格同期）+ 警告 + エラーを表示",
      "levelGuideDebug": "Debug（開発環境推奨）: 詳細なデバッグ情報を含む、トラブルシューティングに適しています",
      "levelGuideTrace": "Trace: 非常に詳細なトレース情報、すべての詳細を含む",
      "changeNotice": "現在のレベルは {current} です、保存後 {selected} に切り替わります"
    },
    "title": "ログ管理"
  },
  "nav": {
    "apiDocs": "API文書",
    "clientVersions": "更新通知",
    "config": "設定",
    "data": "データ",
    "errorRules": "エラー",
    "feedback": "報告",
    "docs": "ドキュメント",
    "logs": "ログ",
    "notifications": "通知",
    "prices": "価格表",
    "providers": "供給元",
    "sensitiveWords": "フィルター",
    "requestFilters": "リクエスト"
  },
  "notifications": {
    "title": "プッシュ通知",
    "description": "Webhook プッシュ通知を設定",
    "global": {
      "title": "通知マスタースイッチ",
      "description": "すべてのプッシュ通知機能を有効または無効にする",
      "enable": "プッシュ通知を有効にする"
    },
    "circuitBreaker": {
      "title": "サーキットブレーカーアラート",
      "description": "プロバイダーが完全に遮断された時に即座にアラートを送信",
      "enable": "サーキットブレーカーアラートを有効にする",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "test": "接続テスト"
    },
    "dailyLeaderboard": {
      "title": "日次ユーザー消費ランキング",
      "description": "毎日定時でユーザー消費トップNランキングを送信",
      "enable": "日次ランキングを有効にする",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "time": "送信時刻",
      "timePlaceholder": "09:00",
      "timeError": "時刻形式エラー、HH:mm形式である必要があります",
      "topN": "トップN件表示",
      "test": "接続テスト"
    },
    "costAlert": {
      "title": "コストアラート",
      "description": "ユーザー/プロバイダーの消費がクォータしきい値を超えた時にアラートをトリガー",
      "enable": "コストアラートを有効にする",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "webhookTypeWeCom": "企業微信",
      "webhookTypeFeishu": "飛書",
      "webhookTypeUnknown": "不明なプラットフォーム。企業微信または飛書のWebhook URLを使用してください",
      "threshold": "アラートしきい値",
      "thresholdLabel": "アラートしきい値: {percent}%",
      "thresholdHelp": "消費がクォータの{percent}%に達した時にアラート",
      "interval": "チェック間隔（分）",
      "test": "接続テスト"
    },
    "form": {
      "save": "設定を保存",
      "saving": "保存中...",
      "loading": "読み込み中...",
      "success": "通知設定を保存し、タスクを再スケジュールしました",
      "saveFailed": "保存に失敗しました",
      "saveError": "設定の保存に失敗しました",
      "loadError": "通知設定の読み込みに失敗しました",
      "webhookRequired": "まずWebhook URLを入力してください",
      "testSuccess": "テストメッセージを送信しました",
      "testFailed": "テストに失敗しました",
      "testFailedRetry": "テストに失敗しました。再試行してください",
      "testError": "接続テストに失敗しました",
      "testNoResult": "テストは成功しましたが、結果が返されませんでした"
    }
  },
  "prices": {
    "title": "価格表",
    "description": "プラットフォーム基本設定とモデル価格を管理します",
    "section": {
      "title": "モデル価格",
      "description": "AIモデルの価格設定を管理します"
    },
    "searchPlaceholder": "モデル名を検索...",
    "sync": {
      "button": "LiteLLM価格を同期",
      "syncing": "同期中...",
      "successWithChanges": "価格表を更新: {added}件追加、{updated}件更新、{unchanged}件変化なし",
      "successNoChanges": "価格表は最新です。更新の必要はありません",
      "failed": "同期に失敗しました",
      "failedError": "同期に失敗しました: {error}",
      "failedNoResult": "価格表は更新されましたが結果が返されていません",
      "noModels": "モデル価格が見つかりません",
      "partialFailure": "一部更新が成功しましたが、{failed}件のモデルが失敗しました"
    },
    "table": {
      "modelName": "モデル名",
      "type": "タイプ",
      "provider": "プロバイダー",
      "inputPrice": "入力価格 ($/M)",
      "outputPrice": "出力価格 ($/M)",
      "updatedAt": "更新日時",
      "typeChat": "チャット",
      "typeImage": "画像生成",
      "typeCompletion": "補完",
      "typeUnknown": "不明",
      "loading": "読み込み中...",
      "noMatch": "一致するモデルが見つかりません",
      "noDataTitle": "価格データがありません",
      "noDataHint": "システムは組み込み価格表を持っています。上のボタンを使用して同期または更新してください。"
    },
    "pagination": {
      "showing": "{from}〜{to}件を表示（全{total}件）",
      "previous": "前へ",
      "next": "次へ",
      "perPage": "1ページあたり{size}件"
    },
    "stats": {
      "totalModels": "合計{count}個のモデル",
      "searchResults": "{count}件の検索結果",
      "lastUpdated": "最終更新: {time}"
    },
    "dialog": {
      "title": "モデル価格表を更新",
      "description": "モデル価格データを含むJSONファイルを選択してアップロード",
      "selectFile": "JSONファイルをクリックして選択、またはドラッグしてください",
      "fileSizeLimit": "ファイルサイズは10MBを超えることはできません",
      "fileSizeLimitSmall": "ファイルサイズは10MB以下です",
      "invalidFileType": "JSON形式のファイルを選択してください",
      "fileTooLarge": "ファイルサイズが10MBを超えています",
      "upload": "アップロードして更新",
      "uploading": "アップロード中...",
      "updatePriceTable": "価格表を更新",
      "updating": "更新中...",
      "selectJson": "JSONファイルを選択",
      "updateSuccess": "価格表が正常に更新されました。{count}個のモデルを更新しました",
      "updateFailed": "更新に失敗しました",
      "systemHasBuiltIn": "システムは組み込み価格表を持っています",
      "manualDownload": "手動でダウンロードすることもできます",
      "latestPriceTable": "最新価格表",
      "andUploadViaButton": "、上のボタンでアップロードしてください",
      "supportedModels": "現在{count}個のモデルをサポート",
      "results": {
        "title": "更新結果",
        "total": "合計: {total}個のモデル",
        "success": "成功: {success}",
        "failed": "失敗: {failed}",
        "skipped": "スキップ: {skipped}",
        "details": "詳細",
        "viewDetails": "詳細ログを表示"
      }
    }
  },
  "providers": {
    "add": "プロバイダーを追加",
    "addFailed": "プロバイダーの追加に失敗しました",
    "addProvider": "プロバイダーを追加",
    "addSuccess": "プロバイダーが正常に追加されました",
    "circuitBroken": "サーキットブレーカー作動中",
    "clone": "プロバイダーを複製",
    "cloneFailed": "コピーに失敗しました",
    "confirmDelete": "このプロバイダーを削除してもよろしいですか？",
    "confirmDeleteDesc": "プロバイダー「{name}」を削除してもよろしいですか？この操作は元に戻せません。",
    "confirmDeleteProvider": "プロバイダーの削除を確認しますか？",
    "confirmDeleteProviderDesc": "サービスプロバイダー「{name}」を削除してもよろしいですか？この操作は復元できません。",
    "createProvider": "サービスプロバイダーを追加",
    "delete": "プロバイダーを削除",
    "deleteFailed": "プロバイダーの削除に失敗しました",
    "deleteSuccess": "削除成功",
    "description": "APIサービスプロバイダーを設定し、可用性ステータスを維持します。",
    "disabledStatus": "無効",
    "displayCount": "{filtered} / {total}個のプロバイダーを表示",
    "edit": "プロバイダーを編集",
    "editFailed": "プロバイダーの更新に失敗しました",
    "editProvider": "サービスプロバイダーを編集",
    "enabledStatus": "有効",
    "form": {
      "proxyTest": {
        "fillUrlFirst": "まずプロバイダーURLを入力してください",
        "testFailed": "テスト失敗",
        "testFailedRetry": "テストに失敗しました。再試行してください",
        "noResult": "テスト成功ですが結果が返されませんでした",
        "connectionSuccess": "接続成功",
        "connectionFailed": "接続失敗",
        "viaProxy": "（プロキシ経由）",
        "viaDirect": "（直接接続）",
        "responseTime": "応答時間:",
        "statusCode": "ステータスコード:",
        "connectionMethod": "接続方式:",
        "proxy": "プロキシ",
        "direct": "直接接続",
        "errorType": "エラータイプ:",
        "testing": "テスト中...",
        "testConnection": "接続テスト",
        "timeoutError": "接続タイムアウト（5秒）。以下を確認してください：\n1. プロキシサーバーにアクセスできるか\n2. プロキシアドレスとポートが正しいか\n3. プロキシ認証情報が正しいか",
        "proxyError": "プロキシエラー:",
        "networkError": "ネットワークエラー:"
      },
      "apiTest": {
        "fillUrlFirst": "まずプロバイダーURLを入力してください",
        "invalidUrl": "プロバイダーURLが無効です（http/httpsのみ対応）",
        "fillKeyFirst": "まずAPIキーを入力してください",
        "testFailed": "テスト失敗",
        "testFailedRetry": "テスト失敗、再試行してください",
        "noResult": "テスト成功ですが結果が返されませんでした",
        "testSuccess": "モデルテスト成功",
        "testApi": "プロバイダーモデルテスト",
        "testing": "テスト中...",
        "apiFormat": "プロバイダータイプ",
        "selectApiFormat": "テストするプロバイダータイプを選択",
        "apiFormatDesc": "手動で変更しない限り、ルーティング設定のプロバイダータイプと同期",
        "formatAnthropicMessages": "Claude (Anthropic Messages API)",
        "formatOpenAIChat": "OpenAI Compatible",
        "formatOpenAIResponses": "Codex (Response API)",
        "testModel": "テストモデル",
        "testModelDesc": "空欄の場合はデフォルトモデルを使用、手動入力も可能",
        "requestConfig": "リクエスト設定",
        "presetConfig": "プリセット",
        "customConfig": "カスタム",
        "selectPreset": "プリセットテンプレートを選択",
        "presetDesc": "プリセットテンプレートには、リレーサービス検証用の本物のCLIリクエストパターンが含まれています",
        "customPayloadPlaceholder": "{\"model\": \"...\", \"messages\": [...]}",
        "customPayloadDesc": "カスタムJSONペイロードを入力してデフォルトのリクエストボディを上書き",
        "successContains": "成功検出キーワード",
        "successContainsPlaceholder": "pong",
        "successContainsDesc": "成功と見なすには、レスポンスにこのキーワードが含まれている必要があります",
        "model": "モデル",
        "responseModel": "応答モデル",
        "responseTime": "応答時間",
        "usage": "トークン使用量",
        "response": "応答内容",
        "error": "エラーメッセージ",
        "unknown": "不明",
        "viewDetails": "詳細を見る",
        "copySuccess": "クリップボードにコピーしました",
        "copyFailed": "コピー失敗",
        "copyResult": "結果をコピー",
        "close": "閉じる",
        "success": "成功",
        "failed": "失敗",
        "streamInfo": "ストリーム応答情報",
        "chunksReceived": "受信したチャンク",
        "streamFormat": "ストリーム形式",
        "streamResponse": "ストリーム応答",
        "chunksCount": "{count} チャンク受信 ({format})",
        "truncatedPreview": "先頭 {length} 文字を表示、全文はコピーして確認",
        "truncatedBrief": "先頭 {length} 文字を表示、全文は「詳細を見る」をクリック",
        "copyFormat": {
          "testResult": "テスト結果",
          "message": "メッセージ",
          "errorDetails": "エラー詳細"
        },
        "disclaimer": {
          "title": "注意",
          "realRequest": "テストはプロバイダーに実際のリクエストを送信し、少量のクォータを消費する可能性があります",
          "resultReference": "プロバイダーによって結果が異なる場合があり、参考用です",
          "confirmConfig": "プロバイダーURL、APIキー、モデル設定を確認してください"
        },
        "resultCard": {
          "status": {
            "green": "利用可能",
            "yellow": "不安定",
            "red": "利用不可"
          },
          "dialogTitle": "プロバイダーテスト詳細",
          "validation": {
            "title": "三層検証詳細",
            "http": {
              "title": "Tier 1: HTTPステータス",
              "statusCode": "ステータスコード",
              "passed": "2xx/3xx 成功",
              "failed": "4xx/5xx 失敗"
            },
            "latency": {
              "title": "Tier 2: レイテンシ閾値",
              "actual": "実際のレイテンシ",
              "passed": "閾値内",
              "failed": "閾値超過"
            },
            "content": {
              "title": "Tier 3: コンテンツ検証",
              "target": "ターゲット",
              "passed": "ターゲット文字列を含む",
              "failed": "ターゲットが見つかりません"
            },
            "passed": "合格",
            "failed": "失敗",
            "timeout": "タイムアウト"
          },
          "labels": {
            "http": "HTTP",
            "latency": "レイテンシ",
            "content": "コンテンツ",
            "model": "モデル",
            "firstByte": "最初のバイト",
            "totalLatency": "合計レイテンシ",
            "error": "エラー",
            "responsePreview": "応答プレビュー"
          },
          "timing": {
            "title": "タイミング情報",
            "totalLatency": "合計レイテンシ",
            "firstByte": "最初のバイト",
            "testedAt": "テスト日時"
          },
          "tokenUsage": {
            "title": "トークン使用量",
            "input": "入力",
            "output": "出力",
            "cacheCreation": "キャッシュ作成",
            "cacheRead": "キャッシュ読取"
          },
          "streamInfo": {
            "title": "ストリーム応答情報",
            "isStreaming": "ストリーミング",
            "chunksCount": "チャンク数",
            "yes": "はい",
            "no": "いいえ"
          },
          "rawResponse": {
            "title": "生のレスポンスボディ",
            "hint": "ここに生のレスポンス内容が表示されます。キーワードがレスポンスに含まれているか確認できます。"
          },
          "errorDetails": {
            "title": "エラー詳細",
            "type": "エラータイプ"
          },
          "copyText": {
            "status": "ステータス",
            "message": "メッセージ",
            "latency": "レイテンシ",
            "httpStatus": "HTTPステータス",
            "model": "モデル",
            "usage": "使用量",
            "inputOutput": "入力 {input} / 出力 {output} トークン",
            "response": "応答",
            "error": "エラー",
            "testedAt": "テスト日時",
            "validationDetails": "検証詳細",
            "httpCheck": "HTTPチェック",
            "latencyCheck": "レイテンシチェック",
            "contentCheck": "コンテンツ検証"
          },
          "judgment": "判定"
        }
      },
      "urlPreview": {
        "title": "URL結合プレビュー",
        "invalidUrl": "無効なURL形式",
        "invalidUrlDesc": "有効なHTTP/HTTPSアドレスを入力してください",
        "duplicatePath": "重複パス検出",
        "copy": "コピー",
        "copySuccess": "{name} をクリップボードにコピーしました",
        "copyFailed": "コピーに失敗しました"
      },
      "modelSelect": {
        "allowAllModels": "すべての {type} モデルを許可",
        "selectedCount": "{count} 個のモデルを選択済み",
        "searchPlaceholder": "モデル名を検索...",
        "loading": "読み込み中...",
        "notFound": "モデルが見つかりません",
        "selectAll": "すべて選択 ({count})",
        "clear": "クリア",
        "manualAdd": "手動でモデルを追加",
        "manualPlaceholder": "モデル名を入力（例：gpt-5-turbo）",
        "manualDesc": "任意のモデル名を追加できます（価格表のモデルに限定されません）",
        "claude": "Claude",
        "openai": "OpenAI",
        "gemini": "Gemini",
        "sourceUpstream": "上流",
        "sourceUpstreamDesc": "モデルリストは上流プロバイダーAPIから取得",
        "sourceFallback": "ローカル",
        "sourceFallbackDesc": "ローカル価格表のモデルリストを使用（上流が利用不可または未対応）",
        "refresh": "モデルリストを更新"
      },
      "modelRedirect": {
        "currentRules": "現在のルール ({count})",
        "addNewRule": "新規ルールを追加",
        "sourceModel": "ユーザーがリクエストするモデル",
        "targetModel": "実際に転送されるモデル",
        "sourcePlaceholder": "例：claude-sonnet-4-5-20250929",
        "targetPlaceholder": "例：glm-4.6",
        "add": "追加",
        "sourceEmpty": "ソースモデル名を入力してください",
        "targetEmpty": "ターゲットモデル名を入力してください",
        "alreadyExists": "モデル \"{model}\" のリダイレクトルールは既に存在します",
        "description": "Claude Code クライアントがリクエストするモデル（例：claude-sonnet-4.5）を、上流プロバイダーが実際にサポートするモデル（例：glm-4.6、gemini-pro）にリダイレクトします。コスト最適化やサードパーティAIサービスへの接続に使用します。",
        "emptyState": "リダイレクトルールがありません。ルールを追加すると、システムは自動的にリクエスト内のモデル名を書き換えます。"
      },
      "addRedirect": "リダイレクトを追加",
      "allowAllModels": "✓ すべてのモデルを許可（推奨）",
      "apiAddress": "API 地址",
      "apiAddressPlaceholder": "例如: https://open.bigmodel.cn/api/anthropic",
      "apiAddressRequired": "API 地址 *",
      "apiKey": "APIキー",
      "apiKeyCurrent": "当前密钥:",
      "apiKeyLeaveEmpty": "（留空不更改）",
      "apiKeyLeaveEmptyDesc": "留空则不更改密钥",
      "apiKeyOptional": "現在のキーを保持する場合は空のままにしてください",
      "apiKeyPlaceholder": "APIキーを入力",
      "apiKeyRequired": "API 密钥 *",
      "baseUrl": "ベースURL",
      "baseUrlPlaceholder": "例：https://open.bigmodel.cn/api/anthropic",
      "baseUrlRequired": "プロバイダーURLを入力してください",
      "circuitBreakerConfig": "サーキットブレーカー設定",
      "circuitBreakerConfigSummary": "{failureThreshold} 回失敗 / {openDuration} 分間ブレーク / {successThreshold} 回成功で回復 / 各プロバイダー最大 {maxRetryAttempts} 回試行",
      "circuitBreakerDesc": "連続失敗時に自動的にブレークして全体の品質を保護します",
      "clearSearch": "検索をクリア",
      "codexInstructions": "Codexインストラクション方針",
      "codexInstructionsAuto": "自動（推奨）",
      "codexInstructionsDesc": "（スケジューリング方針を決定）",
      "codexInstructionsForce": "公式を強制",
      "codexInstructionsKeep": "元の値を保持",
      "codexStrategyAutoDesc": "透传客户端 instructions，400 错误时自动重试官方 prompt",
      "codexStrategyAutoLabel": "自动 (推荐)",
      "codexStrategyConfig": "Codex Instructions 策略",
      "codexStrategyConfigAuto": "自动 (推荐)",
      "codexStrategyConfigForce": "强制官方",
      "codexStrategyConfigKeep": "透传原样",
      "codexStrategyDesc": "控制如何处理 Codex 请求的 instructions 字段，影响与上游中转站的兼容性",
      "codexStrategyForceDesc": "始终使用官方 Codex CLI instructions（约 4000+ 字）",
      "codexStrategyForceLabel": "强制官方",
      "codexStrategyHint": "提示: 部分严格的 Codex 中转站（如 88code、foxcode）需要官方 instructions，选择\"自动\"或\"强制官方\"策略",
      "codexStrategyKeepDesc": "始终透传客户端 instructions，不自动重试（适用于宽松中转站）",
      "codexStrategyKeepLabel": "透传原样",
      "codexStrategySelect": "策略选择",
      "collapseAll": "折叠全部高级配置",
      "confirmAdd": "确认添加",
      "confirmAddPending": "添加中...",
      "confirmUpdate": "确认更新",
      "confirmUpdatePending": "更新中...",
      "costMultiplier": "コスト乗数",
      "costMultiplierDesc": "例：A（コスト1.0x）、C（コスト0.8x）",
      "costMultiplierLabel": "成本倍率",
      "costMultiplierPlaceholder": "1.0",
      "deleteButton": "删除",
      "enabled": "有効",
      "expandAll": "展开全部高级配置",
      "failureThreshold": "失败阈值（次）",
      "failureThresholdDesc": "连续失败多少次后触发熔断",
      "failureThresholdPlaceholder": "5",
      "filterAllProviders": "全部供应商",
      "filterByType": "タイプでフィルタ",
      "filterProvider": "筛选供应商类型",
      "group": "グループ",
      "groupPlaceholder": "例：premium, economy",
      "joinClaudePool": "加入 Claude 调度池",
      "joinClaudePoolDesc": "启用后，此供应商将与 Claude 类型供应商一起参与负载均衡调度",
      "joinClaudePoolHelp": "仅当模型重定向配置中存在映射到 claude-* 模型时可用。启用后，当用户请求 claude-* 模型时，此供应商也会参与调度选择。",
      "leaveEmpty": "無制限の場合は空のままにしてください",
      "limit0Means": "0は無制限を意味します",
      "limit5hLabel": "5小时消费上限 (USD)",
      "limitAmount5h": "5時間支出上限（USD）",
      "limitAmount5hDesc": "例：プロバイダーBが$10制限、$9.8消費済み",
      "limitAmountMonthly": "月間支出上限（USD）",
      "limitAmountWeekly": "週間支出上限（USD）",
      "limitConcurrent": "同時セッション数制限",
      "limitConcurrentDesc": "例：プロバイダーC制限2、現在アクティブセッション数：2",
      "limitConcurrentLabel": "并发 Session 上限",
      "limitMonthlyLabel": "月消费上限 (USD)",
      "limitPlaceholder0": "0 表示无限制",
      "limitPlaceholderUnlimited": "留空表示无限制",
      "limitWeeklyLabel": "周消费上限 (USD)",
      "modelRedirects": "モデルリダイレクト",
      "modelRedirectsAddNew": "添加新规则",
      "modelRedirectsCurrentRules": "当前规则 ({count})",
      "modelRedirectsDesc": "Claudeモデルリクエストを他のサポートされるモデルにリダイレクトします",
      "modelRedirectsEmpty": "暂无重定向规则。添加规则后，系统将自动重写请求中的模型名称。",
      "modelRedirectsExists": "模型 \"{model}\" 已存在重定向规则",
      "modelRedirectsLabel": "模型重定向配置",
      "modelRedirectsOptional": "(可选)",
      "modelRedirectsSourceModel": "用户请求的模型",
      "modelRedirectsSourcePlaceholder": "例如: claude-sonnet-4-5-20250929",
      "modelRedirectsSourceRequired": "源模型名称不能为空",
      "modelRedirectsTargetModel": "实际转发的模型",
      "modelRedirectsTargetPlaceholder": "例如: glm-4.6",
      "modelRedirectsTargetRequired": "目标模型名称不能为空",
      "modelWhitelist": "模型白名单",
      "modelWhitelistAllowAll": "允许所有 {type} 模型",
      "modelWhitelistAllowAllClause": "允许所有 Claude 模型",
      "modelWhitelistAllowAllOpenAI": "允许所有 OpenAI 模型",
      "modelWhitelistClear": "清空",
      "modelWhitelistDesc": "限制此供应商可以处理的模型。默认情况下，供应商可以处理该类型下的所有模型。",
      "modelWhitelistLabel": "允许的模型",
      "modelWhitelistLoading": "加载中...",
      "modelWhitelistManualAdd": "手动添加模型",
      "modelWhitelistManualDesc": "支持添加任意模型名称（不限于价格表中的模型）",
      "modelWhitelistManualPlaceholder": "输入模型名称（如 gpt-5-turbo）",
      "modelWhitelistNotFound": "未找到模型",
      "modelWhitelistSearchPlaceholder": "搜索模型名称...",
      "modelWhitelistSelectAll": "全选 ({count})",
      "modelWhitelistSelected": "已选择 {count} 个模型",
      "modelWhitelistSelectedOnly": "仅允许选中的 {count} 个模型。其他模型的请求不会调度到此供应商。",
      "name": {
        "label": "プロバイダー名 *",
        "placeholder": "例: Zhipu"
      },
      "namePlaceholder": "プロバイダー名を入力",
      "openDuration": "熔断时长（分钟）",
      "openDurationDesc": "熔断后多久自动进入半开状态",
      "openDurationPlaceholder": "30",
      "priority": "優先度",
      "priorityDesc": "同じ優先度内では、コスト乗数の低い順でソートされます",
      "priorityLabel": "优先级",
      "priorityPlaceholder": "0",
      "providerGroupDesc": "供应商分组标签。只有用户的 providerGroup 与此值匹配时，该用户才能使用此供应商。示例：设置为 \"premium\" 表示只供 providerGroup=\"premium\" 的用户使用",
      "providerGroupLabel": "供应商分组",
      "providerGroupPlaceholder": "例如: premium, economy",
      "providerName": "服务商名称",
      "providerNamePlaceholder": "例如: 智谱",
      "providerNameRequired": "服务商名称 *",
      "providerType": "プロバイダータイプ",
      "providerTypeDesc": "选择供应商的 API 格式类型。",
      "providerTypeDisabledNote": "注：Gemini CLI 和 OpenAI Compatible 类型功能正在开发中，暂不可用",
      "proxy": "プロキシ",
      "proxyAddressFormats": "支持格式:",
      "proxyAddressLabel": "代理地址",
      "proxyAddressOptional": "(可选)",
      "proxyAddressPlaceholder": "例如: http://proxy.example.com:8080 或 socks5://127.0.0.1:1080",
      "proxyConfig": "代理配置",
      "proxyConfigDesc": "配置代理服务器以改善供应商连接性（支持 HTTP、HTTPS、SOCKS4、SOCKS5）",
      "proxyConfigNone": "未配置",
      "proxyConfigSummary": "已配置代理",
      "proxyConfigSummaryFallback": " (启用降级)",
      "proxyConfigured": "プロキシが設定されています",
      "proxyFallback": "プロキシ失敗時のフォールバック",
      "proxyFallbackDesc": "プロキシ失敗時に直接接続にフォールバックします",
      "proxyFallbackLabel": "代理失败时降级到直连",
      "proxyNotConfigured": "未設定",
      "proxyTestButton": "测试连接",
      "proxyTestDesc": "测试通过配置的代理访问供应商 URL（使用 HEAD 请求，不消耗额度）",
      "proxyTestFailed": "连接失败",
      "proxyTestFillUrl": "请先填写供应商 URL",
      "proxyTestLabel": "连接测试",
      "proxyTestNetworkError": "网络错误: {error}",
      "proxyTestProxyError": "代理错误: {error}",
      "proxyTestResponseTime": "响应时间: {time}",
      "proxyTestResultConnectionMethod": "连接方式: {via}",
      "proxyTestResultConnectionMethodDirect": "直连",
      "proxyTestResultConnectionMethodProxy": "代理",
      "proxyTestResultErrorType": "错误类型: {type}",
      "proxyTestResultFailed": "连接失败",
      "proxyTestResultMessage": "{message}",
      "proxyTestResultResponseTime": "响应时间: {time}ms",
      "proxyTestResultStatusCode": "状态码: {code}",
      "proxyTestResultSuccess": "连接成功 {via}",
      "proxyTestStatusCode": "| 状态码: {code}",
      "proxyTestSuccess": "连接成功",
      "proxyTestTesting": "测试中...",
      "proxyTestTimeout": "连接超时（5秒）。请检查：\n1. 代理服务器是否可访问\n2. 代理地址和端口是否正确\n3. 代理认证信息是否正确",
      "proxyTestViaDirect": "（直连）",
      "proxyTestViaProxy": "（通过代理）",
      "proxyUrl": "プロキシアドレス",
      "proxyUrlPlaceholder": "例：http://proxy.example.com:8080 または socks5://127.0.0.1:1080",
      "rateLimitConfig": "限流配置",
      "rateLimitConfigNone": "无限制",
      "rateLimitConfigSummary": "5h: ${fiveHour}, 周: ${weekly}, 月: ${monthly}, 并发: {concurrent}",
      "remark": "備考",
      "remarkPlaceholder": "オプション：説明を追加...",
      "removeRedirect": "リダイレクトを削除",
      "routingConfig": "路由配置",
      "routingConfigNone": "未配置",
      "routingConfigSummary": "{models} 个模型白名单, {redirects} 个重定向",
      "scheduleParams": "调度参数",
      "searchClear": "清除搜索",
      "searchPlaceholder": "プロバイダー名、URL、備考で検索...",
      "selectProviderType": "プロバイダータイプを選択",
      "sort": "プロバイダーをソート",
      "sortByCost": "コスト順",
      "sortByCreated": "作成日順（新-旧）",
      "sortByName": "名前順（A-Z）",
      "sortByPriority": "優先度順（高-低）",
      "sortByWeight": "重み順（高-低）",
      "sourceModel": "ソースモデル名",
      "sourceModelPlaceholder": "例：claude-sonnet-4-5-20250929",
      "sourceModelRequired": "ソースモデル名は空にできません",
      "successThreshold": "恢复阈值（次）",
      "successThresholdDesc": "半开状态下成功多少次后完全恢复",
      "successThresholdPlaceholder": "2",
      "targetModel": "ターゲットモデル名",
      "targetModelPlaceholder": "例：glm-4.6",
      "targetModelRequired": "ターゲットモデル名は空にできません",
      "testProxy": "接続をテスト",
      "testProxyFailed": "プロキシテストに失敗しました",
      "testProxyFailedError": "接続テスト失敗：",
      "testProxySuccess": "プロキシ接続成功",
      "validUrlRequired": "请输入有效的 API 地址",
      "websiteUrl": {
        "label": "プロバイダー公式サイト",
        "placeholder": "https://example.com",
        "desc": "管理ページへのクイックアクセス用"
      },
      "websiteUrlDesc": "供应商官网地址，用于快速跳转管理",
      "websiteUrlInvalid": "请输入有效的供应商官网地址",
      "websiteUrlPlaceholder": "https://example.com",
      "weight": "重み",
      "weightDesc": "加重ランダム確率。同じ優先度内では、重みが高いほど選択される確率が高くなります。",
      "weightLabel": "权重",
      "weightPlaceholder": "1",
      "title": {
        "create": "プロバイダーを追加",
        "edit": "プロバイダーを編集"
      },
      "url": {
        "label": "API アドレス *",
        "placeholder": "例: https://open.bigmodel.cn/api/anthropic"
      },
      "key": {
        "label": "API キー",
        "leaveEmpty": "（空欄のままにすると変更しません）",
        "placeholder": "API キーを入力",
        "leaveEmptyDesc": "空欄のままにすると既存のキーを保持します",
        "currentKey": "現在のキー: {key}"
      },
      "buttons": {
        "expandAll": "高度な設定をすべて展開",
        "collapseAll": "高度な設定をすべて折りたたむ",
        "submit": "追加を確定",
        "submitting": "追加中...",
        "update": "更新を確定",
        "updating": "更新中...",
        "delete": "削除"
      },
      "common": {
        "core": "コア"
      },
      "sections": {
        "routing": {
          "title": "ルーティング",
          "summary": {
            "models": "許可モデル {count} 件",
            "redirects": "リダイレクト {count} 件",
            "none": "未設定"
          },
          "providerType": {
            "label": "プロバイダー種別",
            "desc": "（スケジューリングに影響）",
            "placeholder": "プロバイダー種別を選択"
          },
          "providerTypeDesc": "プロバイダーの API 形式を選択します。",
          "providerTypeDisabledNote": "注: OpenAI Compatible は開発中のため、現在は使用できません",
          "modelRedirects": {
            "label": "モデルリダイレクト設定",
            "optional": "（任意）"
          },
          "joinClaudePool": {
            "label": "Claude ルーティングプールに参加",
            "desc": "有効にすると、Claude 系のプロバイダーと共に負荷分散に参加します",
            "help": "claude-* へのリダイレクトがある場合のみ利用できます。ユーザーが claude-* モデルを要求した際に本プロバイダーも選択対象になります。"
          },
          "unifiedClientId": {
              "label": "統一クライアント識別子",
              "desc": "有効にすると、上流プロバイダーには常に同じクライアント識別子でリクエストが送信されます（Claude / Claude-Auth プロバイダーのみ対象）。",
              "idLabel": "統一クライアント ID",
              "regenerate": "再生成",
              "help": "ID は 64 文字の 16 進数文字列です。自動生成された値をそのまま利用し、異なるデプロイ間で使い回さないことを推奨します。"
            },
          "preserveClientIp": {
            "label": "クライアント IP を転送",
            "desc": "x-forwarded-for / x-real-ip を上流に渡します（実際の IP が露出する可能性）",
            "help": "プライバシー保護のためデフォルトはオフ。上流側で端末 IP が必要な場合のみ有効化してください。"
          },
          "modelWhitelist": {
            "title": "モデル許可リスト",
            "desc": "このプロバイダーが処理できるモデルを制限します。既定では同タイプのすべてのモデルを処理できます。",
            "label": "許可するモデル",
            "optional": "（任意）",
            "allowAll": "✓ すべてのモデルを許可（推奨）",
            "selectedOnly": "選択した {count} 件のモデルのみ許可します。他のモデルはこのプロバイダーにルーティングされません。",
            "moreModels": "+{count} 件 さらに表示"
          },
          "scheduleParams": {
            "title": "スケジューリング設定",
            "priority": {
              "label": "優先度",
              "placeholder": "0",
              "desc": "値が小さいほど優先度が高くなります（0 が最も高い）。システムは最も高い優先度のプロバイダーのみから選択します。推奨: メイン=0、予備=1、緊急=2"
            },
            "weight": {
              "label": "重み",
              "placeholder": "1",
              "desc": "重み付きランダム。同一優先度内では重みが高いほど選ばれる確率が上がります。例 1:2:3 ≈ 16%:33%:50%"
            },
            "costMultiplier": {
              "label": "コスト倍率",
              "placeholder": "1.0",
              "desc": "コスト計算の倍率。公式=1.0、20% 安い=0.8、20% 高い=1.2（小数4桁まで）"
            },
            "group": {
              "label": "プロバイダーグループ",
              "placeholder": "例: premium, economy",
              "desc": "グループタグ。ユーザーの providerGroup が一致する場合のみ利用可能。例: \"premium\" に設定すると providerGroup=\"premium\" のユーザーのみ対象"
            }
          },
          "context1m": {
            "label": "1M コンテキストウィンドウ",
            "options": {
              "inherit": "継承（クライアントに従う）",
              "forceEnable": "強制有効化",
              "disabled": "無効"
            },
            "desc": "1M コンテキストウィンドウのサポートを設定します。Sonnet モデル（claude-sonnet-4-5、claude-sonnet-4）にのみ適用されます。有効時は段階的料金が適用されます。"
          }
        },
        "rateLimit": {
          "title": "レート制限",
          "summary": {
            "fiveHour": "5h: ${amount}",
            "weekly": "週: ${amount}",
            "monthly": "月: ${amount}",
            "concurrent": "同時: {count}",
            "none": "無制限"
          },
          "limit5h": {
            "label": "5時間の上限 (USD)",
            "placeholder": "空欄で無制限"
          },
          "limitWeekly": {
            "label": "週の上限 (USD)",
            "placeholder": "空欄で無制限"
          },
          "limitMonthly": {
            "label": "月の上限 (USD)",
            "placeholder": "空欄で無制限"
          },
          "limitConcurrent": {
            "label": "同時セッション上限",
            "placeholder": "0 は無制限"
          }
        },
        "circuitBreaker": {
          "title": "サーキットブレーカー設定",
          "summary": "{failureThreshold} 回失敗 / {openDuration} 分間ブレーク / {successThreshold} 回成功で回復 / 各プロバイダー最大 {maxRetryAttempts} 回試行",
          "desc": "連続失敗時に自動的にブレークして全体の品質を保護します",
          "failureThreshold": {
            "label": "失敗しきい値（回）",
            "placeholder": "5",
            "desc": "何回連続失敗でブレークするか"
          },
          "openDuration": {
            "label": "ブレーク時間（分）",
            "placeholder": "30",
            "desc": "ブレーク後、半開に移行するまでの時間"
          },
          "successThreshold": {
            "label": "回復しきい値（回）",
            "placeholder": "2",
            "desc": "半開状態で何回成功したら完全回復するか"
          },
          "maxRetryAttempts": {
            "label": "プロバイダーごとの最大試行回数",
            "placeholder": "2",
            "desc": "初回呼び出しを含め、同一プロバイダーで試行する上限。超えると他のプロバイダーへ切り替えます。未入力の場合はデフォルト値を使用。"
          }
        },
        "proxy": {
          "title": "プロキシ設定",
          "summary": {
            "configured": "プロキシ設定済み",
            "fallback": "（フォールバック有効）",
            "none": "未設定"
          },
          "desc": "プロキシを設定して接続性を改善します（HTTP、HTTPS、SOCKS4、SOCKS5）",
          "url": {
            "label": "プロキシ URL",
            "optional": "（任意）",
            "placeholder": "例: http://proxy.example.com:8080 または socks5://127.0.0.1:1080",
            "formats": "対応フォーマット:"
          },
          "fallback": {
            "label": "プロキシ失敗時は直接接続にフォールバック",
            "desc": "有効にすると、プロキシ接続が失敗した場合に直接接続を試行します"
          },
          "test": {
            "label": "接続テスト",
            "desc": "設定したプロキシ経由でプロバイダー URL への接続をテストします（HEAD リクエスト、課金なし）"
          }
        },
        "timeout": {
          "title": "タイムアウト設定",
          "summary": "初回バイト: {streaming}s | ストリーム間隔: {idle}s | 非ストリーミング: {nonStreaming}s",
          "desc": "リクエストのタイムアウト時間を設定します。0 は無効を意味します",
          "streamingFirstByte": {
            "label": "ストリーミング初バイトタイムアウト（秒）",
            "placeholder": "30",
            "desc": "ストリーミングリクエストの初バイトタイムアウト、範囲1～120秒、デフォルト30秒",
            "core": "true"
          },
          "streamingIdle": {
            "label": "ストリーミングアイドルタイムアウト（秒）",
            "placeholder": "60",
            "desc": "ストリーミングリクエストのアイドルタイムアウト、範囲60～600秒、0で無効化（途中停止防止）",
            "core": "true"
          },
          "nonStreamingTotal": {
            "label": "非ストリーミング総タイムアウト（秒）",
            "placeholder": "600",
            "desc": "非ストリーミングリクエストの総タイムアウト、範囲60～1200秒、デフォルト600秒（10分）",
            "core": "true"
          },
          "disableHint": "0に設定するとタイムアウトを無効にします（カナリアロールバックシナリオのみ、非推奨）"
        },
        "codexStrategy": {
          "title": "Codex Instructions ポリシー",
          "summary": {
            "auto": "自動（推奨）",
            "force": "公式を強制",
            "keep": "そのまま透過"
          },
          "desc": "Codex リクエストの instructions フィールドの扱いを制御します。上流ゲートウェイとの互換性に影響します。",
          "select": {
            "label": "ポリシー選択",
            "placeholder": "戦略を選択",
            "auto": {
              "label": "自動（推奨）",
              "desc": "クライアントの instructions を透過し、400 エラー時は公式プロンプトで自動再試行"
            },
            "force": {
              "label": "公式を強制",
              "desc": "常に公式の Codex CLI instructions を使用（約 4000+ 文字）"
            },
            "keep": {
              "label": "そのまま透過",
              "desc": "常にクライアントの instructions を透過し、自動再試行しない（緩い中継向け）"
            }
          },
          "hint": "ヒント: 88code や foxcode など一部の厳格な Codex 中継では公式 instructions が必要です。「自動」または「公式を強制」を選択してください。"
        },
        "mcpPassthrough": {
          "title": "MCP パススルー設定",
          "summary": {
            "none": "無効",
            "minimax": "Minimax",
            "glm": "GLM",
            "custom": "カスタム (予約)"
          },
          "desc": "有効にすると、MCP ツール呼び出しを指定された AI プロバイダにパススルーします（例：minimax の画像認識、Web 検索）",
          "select": {
            "label": "パススルータイプ",
            "none": {
              "label": "無効",
              "desc": "MCP パススルーを有効にしません（デフォルト）"
            },
            "minimax": {
              "label": "Minimax",
              "desc": "minimax MCP サービスにパススルー（画像認識、Web 検索などをサポート）"
            },
            "glm": {
              "label": "GLM",
              "desc": "GLM MCP サービスにパススルー（画像分析、動画分析などをサポート）"
            },
            "custom": {
              "label": "カスタム",
              "desc": "カスタム MCP サービスにパススルー（予約、未実装）"
            },
            "placeholder": "パススルータイプを選択"
          },
          "hint": "ヒント: MCP パススルーにより、Claude Code クライアントは第三者の AI プロバイダー提供のツール機能（画像認識、Web 検索など）を使用できます",
          "urlLabel": "MCP パススルー URL",
          "urlPlaceholder": "https://api.minimaxi.com",
          "urlDesc": "MCP サービスベース URL。空のままにすると、プロバイダー URL から自動的に抽出されます",
          "urlAuto": "自動抽出: {url}"
        }
      },
      "providerTypes": {
        "claude": "Claude (Anthropic Messages API)",
        "claudeAuth": "Claude (Anthropic Auth Token)",
        "codex": "Codex (Response API)",
        "gemini": "Gemini (Google Gemini API)",
        "geminiCli": "Gemini CLI",
        "geminiCliDisabled": "",
        "openaiCompatible": "OpenAI Compatible",
        "openaiCompatibleDisabled": " - 開発中"
      },
      "deleteDialog": {
        "title": "プロバイダーを削除",
        "description": "プロバイダー「{name}」を削除しますか？この操作は元に戻せません。",
        "cancel": "キャンセル",
        "confirm": "削除を確定"
      },
      "failureThresholdConfirmDialog": {
        "title": "特別な設定を確認",
        "descriptionDisabledPrefix": "サーキットブレーカーの失敗閾値を",
        "descriptionDisabledValue": "0",
        "descriptionDisabledMiddle": "に設定しています。これは",
        "descriptionDisabledAction": "サーキットブレーカーを無効化",
        "descriptionDisabledSuffix": "することを意味し、プロバイダーは連続した失敗によって遮断されません。",
        "descriptionHighValuePrefix": "サーキットブレーカーの失敗閾値を",
        "descriptionHighValueSuffix": "に設定しています。これは高い値であり、プロバイダーが多数の失敗の後にのみ遮断される可能性があります。",
        "confirmQuestion": "この設定を保存してもよろしいですか？",
        "cancel": "キャンセル",
        "confirm": "保存を確定"
      },
      "errors": {
        "invalidUrl": "有効な API アドレスを入力してください",
        "invalidWebsiteUrl": "有効な公式サイト URL を入力してください",
        "addFailed": "プロバイダーの追加に失敗しました",
        "updateFailed": "プロバイダーの更新に失敗しました",
        "deleteFailed": "プロバイダーの削除に失敗しました"
      },
      "success": {
        "created": "プロバイダーを追加しました",
        "createdDesc": "「{name}」を追加しました"
      }
    },
    "guide": {
      "after": "过滤后：",
      "before": "过滤前：",
      "bestPracticesConcurrent": "• 并发控制：根据供应商 API 限制设置 Session 并发数",
      "bestPracticesCost": "• 成本倍率：官方倍率为 1.0，自建服务可设置为 0.8-1.2",
      "bestPracticesLimit": "• 限额设置：根据预算设置 5 小时、7 天、30 天限额",
      "bestPracticesPriority": "• 优先级设置：核心供应商设为 0，备用供应商设为 1-3",
      "bestPracticesTitle": "最佳实践建议",
      "bestPracticesWeight": "• 权重配置：根据供应商容量设置权重（容量大 = 权重高）",
      "circuitBreaker": "サーキットブレーカーチェック",
      "circuitBreakerOpen": "Aはフィルタされました、残り：B、C、D",
      "circuitBreakerRecovery": "Aは60秒後に半開状態に自動復帰します",
      "circuitBreakerRecovery5h": "5時間スライディングウィンドウ後に自動復帰",
      "costOptimize": "2️⃣ 成本优化：同优先级内，成本倍率低的供应商有更高概率",
      "costSort": "コストベースのソートフォールバック",
      "costSortExample": "すべてのプロバイダー：A（default）、B（premium）、C（premium）、D（economy）",
      "costSortProb": "より安いCがより高い選択確率を持ちます",
      "costSortResult": "ソート後：C（0.8x）、A（1.0x）",
      "decision": "决策：",
      "group": "ユーザーグループフィルタリング",
      "groupDesc": "ユーザーがプロバイダーグループを指定した場合、システムはそのグループから優先的に選択します",
      "groupDowngrade": "警告をログに記録し、グローバルプロバイダープールから選択",
      "groupExample": "ユーザーはproviderGroup = 'premium'を設定しました",
      "groupFallback": "グループに利用可能なプロバイダーがない場合は、すべてのプロバイダーにフォールバック",
      "groupFiltered": "AとCのみから選択、BとDはフィルタされます",
      "groupUnavailable": "ユーザーグループ'vip'のすべてのプロバイダーが無効または制限超過です",
      "health": "ヘルスフィルタリング（サーキットブレーカー+レート制限）",
      "healthCheck": "Bが有効で健全かをチェック",
      "healthCheckAmountLimit": "支出制限超過をチェック（5時間、7日、30日）",
      "healthCheckAmountLimitExample": "プロバイダーB制限$10（5時間）、$9.8消費済み",
      "healthCheckCircuit": "プロバイダーA 5回失敗、サーキットブレーカー：オープン",
      "healthCheckConcurrent": "現在のアクティブセッション数がの制限をチェック",
      "healthCheckConcurrentExample": "プロバイダーC制限2、現在アクティブ2セッション",
      "healthFilter": "3️⃣ 健康过滤：自动跳过熔断或超限的供应商",
      "healthFiltered": "Bはフィルタされました（制限に接近）、残り：C、D",
      "healthFiltered2": "Cはフィルタされました（満杯）、残り：D",
      "history": "リクエスト履歴をチェック",
      "historyDesc": "このAPIキーが過去10秒間に使用したプロバイダーをクエリします",
      "priority": "優先度階層化",
      "priorityExample": "異なる優先度を持つ4つのプロバイダーが有効です",
      "priorityFirst": "1️⃣ 优先级优先：只从最高优先级（数值最小）的供应商中选择",
      "priorityResult": "最高優先度（0）にフィルタされました：A、C",
      "priorityStep": "システムは優先度でフィルタし、最高優先度のプロバイダーのみを選択します",
      "randomResult": "最終的にCがランダムに選択されました",
      "randomSelect": "加重ランダム",
      "reset": "サーキットブレーカーを手動リセット",
      "resetSuccess": "サーキットブレーカーがリセットされました",
      "scenario1Desc": "系统首先按优先级过滤，只从最高优先级的供应商中选择",
      "scenario1Step1": "初始状态",
      "scenario1Step1After": "筛选出最高优先级（0）的供应商：A, C",
      "scenario1Step1Before": "供应商 A (优先级 0), B (优先级 1), C (优先级 0), D (优先级 2)",
      "scenario1Step1Decision": "只从 A 和 C 中选择，B 和 D 被过滤",
      "scenario1Step1Desc": "有 4 个已启用的供应商，优先级各不相同",
      "scenario1Step2": "成本排序",
      "scenario1Step2After": "排序后：C (0.8x), A (1.0x)",
      "scenario1Step2Before": "A (成本 1.0x), C (成本 0.8x)",
      "scenario1Step2Decision": "成本更低的 C 有更高的被选中概率",
      "scenario1Step2Desc": "在同优先级内，按成本倍率从低到高排序",
      "scenario1Step3": "加权随机",
      "scenario1Step3After": "C 被选中概率 75%, A 被选中概率 25%",
      "scenario1Step3Before": "C (权重 3), A (权重 1)",
      "scenario1Step3Decision": "最终随机选择了 C",
      "scenario1Step3Desc": "使用权重进行随机选择，权重越高被选中概率越大",
      "scenario1Title": "优先级分层选择",
      "scenario2Desc": "如果用户指定了供应商组，系统会优先从该组中选择",
      "scenario2Step1": "检查用户分组",
      "scenario2Step1After": "过滤出 'premium' 组：B, C",
      "scenario2Step1Before": "所有供应商：A (default), B (premium), C (premium), D (economy)",
      "scenario2Step1Decision": "只从 B 和 C 中选择",
      "scenario2Step1Desc": "用户配置了 providerGroup = 'premium'",
      "scenario2Step2": "分组降级",
      "scenario2Step2After": "降级到所有启用的供应商：A, B, C, D",
      "scenario2Step2Before": "用户组 'vip' 内的供应商全部禁用或超限",
      "scenario2Step2Decision": "记录警告并从全局供应商池中选择",
      "scenario2Step2Desc": "如果用户组内没有可用供应商，降级到所有供应商",
      "scenario2Title": "用户分组过滤",
      "scenario3Desc": "系统自动过滤掉熔断或超限的供应商",
      "scenario3Step1": "熔断器检查",
      "scenario3Step1After": "A 被过滤，剩余：B, C, D",
      "scenario3Step1Before": "供应商 A 连续失败 5 次，熔断器状态：open",
      "scenario3Step1Decision": "A 在 60 秒后自动恢复到半开状态",
      "scenario3Step1Desc": "连续失败 5 次后熔断器打开，60 秒内不可用",
      "scenario3Step2": "金额限流",
      "scenario3Step2After": "B 被过滤（接近限额），剩余：C, D",
      "scenario3Step2Before": "供应商 B 的 5 小时限额 $10，已消耗 $9.8",
      "scenario3Step2Decision": "5 小时窗口滑动后自动恢复",
      "scenario3Step2Desc": "检查 5 小时、7 天、30 天的消费额度是否超限",
      "scenario3Step3": "并发 Session 限制",
      "scenario3Step3After": "C 被过滤（已满），剩余：D",
      "scenario3Step3Before": "供应商 C 并发限制 2，当前活跃 Session 数：2",
      "scenario3Step3Decision": "Session 过期（5 分钟）后自动释放",
      "scenario3Step3Desc": "检查当前活跃 Session 数是否超过配置的并发限制",
      "scenario3Title": "健康度过滤（熔断器 + 限流）",
      "scenario4Desc": "连续对话优先使用同一供应商，利用 Claude 的上下文缓存",
      "scenario4Step1": "检查历史请求",
      "scenario4Step1After": "检查 B 是否启用且健康",
      "scenario4Step1Before": "最近一次请求使用了供应商 B",
      "scenario4Step1Decision": "B 可用，直接复用，跳过随机选择",
      "scenario4Step1Desc": "查询该 API Key 最近 10 秒内使用的供应商",
      "scenario4Step2": "复用失效",
      "scenario4Step2After": "进入正常选择流程",
      "scenario4Step2Before": "上次使用的供应商 B 已被禁用或熔断",
      "scenario4Step2Decision": "从其他可用供应商中选择",
      "scenario4Step2Desc": "如果上次使用的供应商不可用，则重新选择",
      "scenario4Title": "会话复用机制",
      "scenariosTitle": "交互式场景演示",
      "session": "セッション再利用メカニズム",
      "sessionDesc": "前回使用したプロバイダーが利用できない場合は再選択します",
      "sessionExample": "最後のリクエストはプロバイダーBを使用しました",
      "sessionExpired": "セッションは期限切れ後に自動的に解放されます（5分）",
      "sessionFallback": "他の利用可能なプロバイダーから選択",
      "sessionLastUsed": "Bは利用可能、直接再利用、ランダム選択をスキップ",
      "sessionReuse": "4️⃣ 会话复用：连续对话复用同一供应商，节省上下文成本",
      "sessionUnavailable": "前回使用したプロバイダーBは無効またはサーキットオープン状態です",
      "step": "步骤",
      "title": "核心原则",
      "weight": "重みに基づく加重ランダム選択",
      "weightCalc": "Cは75％の選択確率、Aは25％",
      "weightExample": "C（重み3）、A（重み1）"
    },
    "keyLoading": "加载中...",
    "noProviders": "暂无服务商配置",
    "noProvidersDesc": "添加你的第一个 API 服务商",
    "notFound": "プロバイダーが見つかりません",
    "official": "官网",
    "resetCircuit": "熔断器已重置",
    "resetCircuitDesc": "供应商 \"{name}\" 的熔断状态已解除",
    "resetCircuitFailed": "重置熔断器失败",
    "scheduling": "スケジューリング戦略の詳細説明",
    "schedulingDesc": "プロバイダー選択の仕組み：優先度階層化、セッション再利用、ロードバランシング、フェイルオーバーを理解します",
    "searchNoResults": "未找到匹配的供应商",
    "searchResults": "找到 {count} 个匹配的供应商",
    "section": {
      "description": "配置上游服务商的金额限流和并发限制，留空表示无限制。",
      "leaderboard": "プロバイダーランキング",
      "title": "服务商管理"
    },
    "addProvider": "プロバイダーを追加",
    "filter": {
      "status": {
        "all": "すべてのステータス",
        "active": "有効",
        "inactive": "無効"
      },
      "groups": {
        "label": "グループ:",
        "all": "すべて",
        "default": "default"
      }
    },
    "subtitle": "プロバイダー管理",
    "subtitleDesc": "上流プロバイダーの支出制限とセッション並行制限を設定します。空のままにすると無制限です。",
    "title": "プロバイダー管理",
    "todayUsage": "今日用量",
    "todayUsageCount": "{count} 次",
    "toggleFailed": "状态切换失败",
    "toggleSuccess": "供应商已{status}",
    "toggleSuccessDesc": "供应商 \"{name}\" 状态已更新",
    "updateFailed": "更新服务商失败",
    "viewKey": "查看完整 API Key",
    "viewKeyDesc": "请妥善保管，不要泄露给他人",
    "types": {
      "claude": {
        "label": "Claude",
        "description": "Anthropic 公式 API"
      },
      "claudeAuth": {
        "label": "Claude Auth",
        "description": "Claude リレーサービス"
      },
      "codex": {
        "label": "Codex",
        "description": "Codex CLI API"
      },
      "gemini": {
        "label": "Gemini",
        "description": "Google Gemini API"
      },
      "geminiCli": {
        "label": "Gemini CLI",
        "description": "Gemini CLI API"
      },
      "openaiCompatible": {
        "label": "OpenAI Compatible",
        "description": "OpenAI 互換 API"
      }
    },
    "list": {
      "priority": "優先度",
      "weight": "重み",
      "costMultiplier": "コスト倍率",
      "todayUsageLabel": "本日の使用量",
      "todayUsageCount": "{count} 回",
      "circuitBroken": "遮断中",
      "officialWebsite": "公式",
      "viewFullKey": "完全な API キーを表示",
      "viewFullKeyDesc": "安全に保管し、他人と共有しないでください",
      "keyLoading": "読み込み中...",
      "confirmDeleteTitle": "プロバイダーの削除を確認しますか?",
      "confirmDeleteMessage": "プロバイダー \"{name}\" を削除してもよろしいですか？この操作は元に戻せません。",
      "deleteButton": "削除",
      "cancelButton": "キャンセル",
      "deleteSuccess": "削除に成功しました",
      "deleteSuccessDesc": "プロバイダー \"{name}\" が削除されました",
      "deleteFailed": "削除に失敗しました",
      "deleteError": "操作中にエラーが発生しました",
      "unknownError": "不明なエラー",
      "getKeyFailed": "キーの取得に失敗しました",
      "keyCopied": "キーがクリップボードにコピーされました",
      "copyFailed": "コピーに失敗しました",
      "clipboardUnavailable": "この環境ではクリップボードを使用できません。手動でコピーしてください。",
      "resetCircuitSuccess": "サーキットブレーカーがリセットされました",
      "resetCircuitSuccessDesc": "プロバイダー \"{name}\" のサーキットブレーカーステータスがクリアされました",
      "resetCircuitFailed": "サーキットブレーカーのリセットに失敗しました",
      "toggleSuccess": "プロバイダーが{status}になりました",
      "toggleSuccessDesc": "プロバイダー \"{name}\" のステータスが更新されました",
      "toggleFailed": "切り替えに失敗しました",
      "statusEnabled": "有効",
      "statusDisabled": "無効"
    },
    "inlineEdit": {
      "save": "保存",
      "cancel": "キャンセル",
      "saveSuccess": "保存に成功しました",
      "saveFailed": "保存に失敗しました",
      "priorityLabel": "優先度",
      "weightLabel": "重み",
      "costMultiplierLabel": "コスト倍率",
      "priorityInvalid": "0 以上の整数を入力してください",
      "weightInvalid": "1〜100 の整数を入力してください",
      "costMultiplierInvalid": "0以上の数値を入力してください"
    },
    "schedulingDialog": {
      "title": "プロバイダースケジューリングルール",
      "description": "システムが高可用性とコスト最適化のために上流プロバイダーをインテリジェントに選択する方法を理解する",
      "triggerButton": "スケジューリングルール",
      "step": "ステップ",
      "before": "前:",
      "after": "後:",
      "decision": "決定:"
    },
    "sort": {
      "byName": "名前順 (A-Z)",
      "byPriority": "優先度順 (高-低)",
      "byWeight": "重み順 (高-低)",
      "byActualPriority": "実際の選択優先順",
      "byCreatedAt": "作成日時順 (新-旧)",
      "placeholder": "プロバイダーを並べ替え"
    },
    "search": {
      "placeholder": "プロバイダー名、URL、メモを検索...",
      "clear": "検索をクリア",
      "found": "{count}件のプロバイダーが見つかりました",
      "notFound": "一致するプロバイダーが見つかりません",
      "showing": "{filtered} / {total} プロバイダーを表示"
    }
  },
  "sensitiveWords": {
    "add": "センシティブワードを追加",
    "addFailed": "センシティブワードの作成に失敗しました",
    "addSuccess": "センシティブワードが正常に作成されました",
    "cacheStats": "キャッシュ統計：部分一致({containsCount}) 完全一致({exactCount}) 正規表現({regexCount})",
    "confirmDelete": "センシティブワード「{word}」を削除してもよろしいですか？",
    "delete": "センシティブワードを削除",
    "deleteFailed": "削除に失敗しました",
    "deleteSuccess": "センシティブワードが正常に削除されました",
    "description": "センシティブコンテンツをブロックするためにセンシティブワードフィルタリングルールを設定します。",
    "dialog": {
      "addDescription": "センシティブワードフィルタリングルールを設定します。マッチしたリクエストはアップストリームに転送されません。",
      "addTitle": "センシティブワードを追加",
      "creating": "作成中...",
      "descriptionLabel": "説明",
      "descriptionPlaceholder": "オプション：説明を追加...",
      "editDescription": "センシティブワード設定を変更します。変更後、自動的にキャッシュがリフレッシュされます。",
      "editTitle": "センシティブワードを編集",
      "matchTypeContains": "部分一致 - テキストにこの単語が含まれている場合ブロック",
      "matchTypeExact": "完全一致 - 完全に一致する場合のみブロック",
      "matchTypeLabel": "マッチタイプ *",
      "matchTypeRegex": "正規表現 - 複雑なパターンマッチングをサポート",
      "saving": "保存中...",
      "wordLabel": "センシティブワード *",
      "wordPlaceholder": "センシティブワードを入力...",
      "wordRequired": "センシティブワードを入力してください"
    },
    "disable": "センシティブワードが無効になりました",
    "edit": "センシティブワードを編集",
    "editFailed": "センシティブワードの更新に失敗しました",
    "editSuccess": "センシティブワードが正常に更新されました",
    "emptyState": "センシティブワードがありません。右上の「センシティブワードを追加」をクリックして設定を開始してください。",
    "enable": "センシティブワードが有効になりました",
    "refreshCache": "キャッシュを更新",
    "refreshCacheFailed": "キャッシュのリフレッシュに失敗しました",
    "refreshCacheSuccess": "キャッシュのリフレッシュに成功しました。{count}個のセンシティブワードを読み込みました",
    "section": {
      "description": "センシティブワードによってブロックされたリクエストはアップストリームに転送されず、課金もされません。部分一致、完全一致、正規表現の3つのモードをサポートしています。",
      "title": "センシティブワードリスト"
    },
    "table": {
      "actions": "操作",
      "createdAt": "作成日時",
      "description": "説明",
      "matchType": "マッチタイプ",
      "matchTypeContains": "部分一致",
      "matchTypeExact": "完全一致",
      "matchTypeRegex": "正規表現",
      "status": "ステータス",
      "word": "センシティブワード"
    },
    "title": "センシティブワード管理",
    "toggleFailed": "トグルに失敗しました",
    "toggleFailedError": "トグルに失敗しました："
  },
  "requestFilters": {
    "nav": "リクエストフィルター",
    "title": "リクエストフィルター",
    "description": "上流に送る前にヘッダー削除/上書きやボディ置換を行い、リクエストをサニタイズします。",
    "add": "フィルター追加",
    "addSuccess": "作成しました",
    "addFailed": "作成に失敗しました",
    "edit": "フィルター編集",
    "editSuccess": "更新しました",
    "editFailed": "更新に失敗しました",
    "delete": "フィルター削除",
    "deleteSuccess": "削除しました",
    "deleteFailed": "削除に失敗しました",
    "enable": "有効",
    "disable": "無効",
    "confirmDelete": "フィルター \"{name}\" を削除しますか?",
    "empty": "フィルターがありません。追加してください。",
    "refreshCache": "キャッシュ更新",
    "refreshSuccess": "{count} 件読み込みました",
    "refreshFailed": "更新に失敗しました",
    "dialog": {
      "createTitle": "フィルター追加",
      "editTitle": "フィルター編集",
      "name": "名称",
      "scope": "スコープ",
      "action": "アクション",
      "target": "対象フィールド/パス",
      "replacement": "置換値 (任意)",
      "description": "説明 (任意)",
      "priority": "優先度",
      "matchType": "マッチタイプ",
      "matchTypeContains": "含む",
      "matchTypeExact": "完全一致",
      "matchTypeRegex": "正規表現",
      "jsonPathPlaceholder": "例: messages.0.content / data.items[0].token",
      "targetPlaceholder": "ヘッダー名またはテキスト/パス",
      "replacementPlaceholder": "文字列またはJSON。空でクリア",
      "save": "保存",
      "saving": "保存中...",
      "validation": {
        "fieldRequired": "名称と対象は必須です"
      },
      "bindingType": "適用先",
      "bindingGlobal": "全プロバイダー（グローバル）",
      "bindingProviders": "特定のプロバイダー",
      "bindingGroups": "プロバイダーグループ",
      "selectProviders": "プロバイダーを選択...",
      "selectGroups": "グループを選択...",
      "searchProviders": "プロバイダー検索...",
      "searchGroups": "グループ検索...",
      "noProvidersFound": "プロバイダーが見つかりません",
      "noGroupsFound": "グループが見つかりません",
      "providersSelected": "{count}件のプロバイダーを選択",
      "groupsSelected": "{count}件のグループを選択",
      "loading": "読み込み中...",
      "clear": "クリア",
      "selectAll": "すべて選択"
    },
    "table": {
      "name": "名称",
      "scope": "スコープ",
      "action": "アクション",
      "target": "対象",
      "replacement": "置換値",
      "priority": "優先度",
      "apply": "適用",
      "status": "状態",
      "createdAt": "作成日時",
      "actions": "操作"
    },
    "scopeLabel": {
      "header": "Header",
      "body": "Body"
    },
    "actionLabel": {
      "remove": "ヘッダー削除",
      "set": "ヘッダー設定",
      "json_path": "JSONパス置換",
      "text_replace": "テキスト置換"
    },
    "applyToAll": "すべてのリクエストに適用",
    "providers": "プロバイダー",
    "groups": "グループ"
  },
  "errorRules": {
    "nav": "エラールール",
    "title": "エラールール管理",
    "description": "自動再試行を行わないクライアントエラールールを管理します。設定後、ルールに一致するエラーは再試行せずユーザーに直接返され、プロバイダーのサーキットブレーカーにもカウントされません。",
    "section": {
      "title": "エラールールリスト"
    },
    "tester": {
      "title": "エラールールテスト",
      "description": "エラーメッセージを入力して、設定済みルールに一致するかと最終的な返却内容を確認します。",
      "inputLabel": "テストするエラーメッセージ",
      "inputPlaceholder": "検証したいエラーメッセージを入力...",
      "testButton": "テストを実行",
      "testing": "テスト中...",
      "matched": "エラールールに一致しました",
      "notMatched": "一致するルールなし",
      "finalResponse": "オーバーライドレスポンス",
      "ruleInfo": "一致したルール",
      "noRule": "一致したルールはありません",
      "category": "カテゴリ",
      "pattern": "パターン",
      "matchType": "マッチタイプ",
      "overrideStatusCode": "オーバーライドステータスコード",
      "testFailed": "テストに失敗しました。再度お試しください",
      "messageRequired": "テストするエラーメッセージを入力してください",
      "warnings": "設定の警告",
      "statusCodeOnlyOverride": "ステータスコードのみオーバーライドされ、レスポンスボディはアップストリームのエラーが使用されます"
    },
    "add": "エラールールを追加",
    "addSuccess": "エラールールが正常に作成されました",
    "addFailed": "エラールールの作成に失敗しました",
    "edit": "エラールールを編集",
    "editSuccess": "エラールールが正常に更新されました",
    "editFailed": "エラールールの更新に失敗しました",
    "delete": "エラールールを削除",
    "deleteSuccess": "エラールールが正常に削除されました",
    "deleteFailed": "削除に失敗しました",
    "enable": "エラールールが有効になりました",
    "disable": "エラールールが無効になりました",
    "toggleFailed": "切り替えに失敗しました",
    "toggleFailedError": "切り替えに失敗しました:",
    "refreshCache": "ルールを同期",
    "refreshCacheSuccess": "ルールが正常に同期され、{count} 個のエラールールがロードされました",
    "refreshCacheFailed": "ルールの同期に失敗しました",
    "cacheStats": "キャッシュ: {totalCount}件のルール",
    "emptyState": "エラールールがまだありません。右上の「エラールールを追加」をクリックして設定を開始してください。",
    "confirmDelete": "エラールール \"{pattern}\" を削除してもよろしいですか？",
    "dialog": {
      "addTitle": "エラールールを追加",
      "addDescription": "エラーメッセージの正規表現パターンを設定します。マッチしたエラーはリトライ不可能なクライアントエラーとして識別されます。",
      "editTitle": "エラールールを編集",
      "editDescription": "エラールール設定を変更します。変更後、キャッシュが自動的に更新されます。",
      "patternLabel": "正規表現パターン *",
      "patternPlaceholder": "正規表現を入力...",
      "patternRequired": "正規表現パターンを入力してください",
      "patternHint": "JavaScript正規表現構文をサポート、例：prompt is too long|invalid.*request",
      "categoryLabel": "ルールカテゴリ *",
      "categoryPlaceholder": "ルールカテゴリを選択",
      "categoryRequired": "ルールカテゴリを選択してください",
      "categoryHint": "分類管理と統計のためのエラーカテゴリを選択",
      "descriptionLabel": "説明",
      "descriptionPlaceholder": "オプション: 説明を追加...",
      "invalidRegex": "正規表現の構文エラー",
      "regexTester": "正規表現テスター",
      "testMessageLabel": "テストメッセージ",
      "testMessagePlaceholder": "テストするエラーメッセージを入力...",
      "matchSuccess": "マッチ成功",
      "matchFailed": "マッチなし",
      "invalidPattern": "無効な正規表現",
      "matchedText": "マッチしたテキスト",
      "defaultRuleHint": "デフォルトルールのパターンは変更できません",
      "enableOverride": "エラーオーバーライドを有効にする",
      "enableOverrideHint": "有効にすると、クライアントに返すエラーレスポンスとステータスコードをカスタマイズできます。元のエラーはデータベースに記録されます。現在、Claude APIエラー形式のみサポートしています。",
      "overrideResponseLabel": "オーバーライドレスポンス（JSON形式）",
      "overrideResponsePlaceholder": "{\n  \"type\": \"error\",\n  \"error\": {\n    \"type\": \"invalid_request_error\",\n    \"message\": \"カスタムメッセージ\"\n  }\n}",
      "overrideResponseHint": "空白のままにするとステータスコードのみオーバーライドします。",
      "overrideStatusCodeLabel": "オーバーライドステータスコード（オプション）",
      "overrideStatusCodePlaceholder": "例: 400",
      "overrideStatusCodeHint": "空白のままにするとアップストリームのステータスコードを使用します。範囲: 400-599。",
      "useTemplate": "Claude Error テンプレート",
      "useTemplateConfirm": "入力済みの内容をテンプレートで上書きしますか？",
      "validJson": "JSON 形式は有効です",
      "invalidJson": "JSON形式が無効です",
      "invalidStatusCode": "ステータスコードは400-599の範囲内でなければなりません",
      "creating": "作成中...",
      "saving": "保存中..."
    },
    "table": {
      "pattern": "正規表現パターン",
      "category": "ルールカテゴリ",
      "description": "説明",
      "status": "ステータス",
      "default": "デフォルト",
      "isEnabled": "有効状態",
      "isDefault": "デフォルトルール",
      "createdAt": "作成日時",
      "actions": "操作"
    },
    "form": {
      "fields": {
        "pattern": "正規表現パターン",
        "category": "ルールカテゴリ",
        "description": "説明"
      },
      "placeholders": {
        "pattern": "例: prompt is too long",
        "category": "カテゴリを選択",
        "description": "オプション: 説明を追加..."
      },
      "labels": {
        "pattern": "正規表現パターン *",
        "category": "ルールカテゴリ *",
        "description": "説明",
        "isEnabled": "有効状態"
      }
    },
    "actions": {
      "add": "追加",
      "edit": "編集",
      "delete": "削除",
      "refresh": "更新",
      "test": "テスト",
      "messages": {
        "success": "操作が成功しました",
        "error": "操作が失敗しました"
      }
    },
    "validation": {
      "patternRequired": "正規表現パターンを入力してください",
      "categoryRequired": "ルールカテゴリを選択してください",
      "patternInvalid": "正規表現の構文エラー",
      "redosRisk": "正規表現に ReDoS リスクがあります。パターンを簡略化してください",
      "patternTooComplex": "正規表現が複雑すぎます"
    },
    "categories": {
      "prompt_limit": "プロンプト長制限",
      "content_filter": "コンテンツフィルター",
      "pdf_limit": "PDF ページ制限",
      "thinking_error": "Thinking フォーマットエラー",
      "parameter_error": "パラメータ検証失敗",
      "invalid_request": "無効なリクエスト",
      "cache_limit": "キャッシュ制御制限"
    },
    "regexTester": {
      "title": "正規表現テスター",
      "testMessage": "テストメッセージ",
      "testMessagePlaceholder": "テストするエラーメッセージを入力...",
      "matchResult": "マッチ結果",
      "matched": "マッチしました",
      "notMatched": "マッチしませんでした",
      "test": "テスト"
    },
    "defaultRules": {
      "cannotDelete": "デフォルトルールは削除できません",
      "cannotDisable": "デフォルトルールは有効のままにすることをお勧めします"
    }
  },
  "mcpPassthroughConfig": "MCP パススルー設定",
  "mcpPassthroughConfigNone": "無効",
  "mcpPassthroughConfigMinimax": "Minimax",
  "mcpPassthroughConfigGlm": "GLM",
  "mcpPassthroughConfigCustom": "カスタム (予約)",
  "mcpPassthroughDesc": "有効にすると、MCP ツール呼び出しを指定された AI プロバイダにパススルーします（例：minimax の画像認識、Web 検索）",
  "mcpPassthroughSelect": "パススルータイプ",
  "mcpPassthroughNoneLabel": "無効",
  "mcpPassthroughNoneDesc": "MCP パススルーを有効にしません（デフォルト）",
  "mcpPassthroughMinimaxLabel": "Minimax",
  "mcpPassthroughMinimaxDesc": "minimax MCP サービスにパススルー（画像認識、Web 検索などをサポート）",
  "mcpPassthroughGlmLabel": "GLM",
  "mcpPassthroughGlmDesc": "GLM MCP サービスにパススルー（画像分析、動画分析などをサポート）",
  "mcpPassthroughCustomLabel": "カスタム",
  "mcpPassthroughCustomDesc": "カスタム MCP サービスにパススルー（予約、未実装）",
  "mcpPassthroughHint": "ヒント: MCP パススルーにより、Claude Code クライアントは第三者の AI プロバイダ提供的ツール機能（画像認識、Web 検索など）を使用できます",
  "mcpPassthroughUrlLabel": "MCP パススルー URL",
  "mcpPassthroughUrlPlaceholder": "https://api.minimaxi.com",
  "mcpPassthroughUrlDesc": "MCP サービスベース URL。空のままにすると、プロバイダ URL から自動的に抽出されます",
  "mcpPassthroughUrlAuto": "自動抽出: {url}"
}
