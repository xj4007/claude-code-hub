{
  "clientVersions": {
    "description": "Управление требованиями версии клиента для обеспечения использования последней стабильной версии. VSCode и CLI управляются отдельно.",
    "empty": {
      "description": "За последние 7 дней не было активных пользователей с распознаваемыми клиентами",
      "title": "Нет данных о клиентах"
    },
    "features": {
      "activeWindow": "Активное окно:",
      "activeWindowDesc": "Учитываются только пользователи с запросами за последние 7 дней",
      "autoDetect": "Система автоматически определяет последнюю стабильную версию (GA версию) каждого типа клиента",
      "blockOldVersion": "Пользователи старых версий будут получать HTTP 400 ошибку и не смогут продолжить использование сервиса",
      "errorMessage": "Сообщение об ошибке будет содержать текущую версию и требуемую версию для обновления",
      "gaRule": "Правила определения:",
      "gaRuleDesc": "Версия считается GA версией, когда её используют более 1 пользователя",
      "recommendation": "Рекомендуемый подход:",
      "recommendationDesc": "Сначала изучите распределение версий ниже, убедитесь в стабильности новой версии перед включением.",
      "title": "Описание функции",
      "whatHappens": "Что произойдет после включения:"
    },
    "section": {
      "distribution": {
        "description": "Показывает информацию о версиях клиентов активных пользователей за последние 7 дней. GA версия рассчитывается независимо для каждого типа клиента.",
        "title": "Распределение версий клиентов"
      },
      "settings": {
        "description": "После включения система будет автоматически проверять версию клиента и блокировать запросы от пользователей со старыми версиями.",
        "title": "Настройки напоминания об обновлении"
      }
    },
    "table": {
      "currentGA": "Текущая GA версия:",
      "internalType": "Внутренний тип:",
      "lastActive": "Последняя активность",
      "latest": "Последняя",
      "needsUpgrade": "Требуется обновление",
      "noUsers": "Нет данных о пользователях",
      "status": "Статус",
      "unknown": "Неизвестно",
      "user": "Пользователь",
      "usersCount": "{count} пользователей",
      "version": "Текущая версия"
    },
    "title": "Напоминание об обновлении клиента",
    "toggle": {
      "description": "При включении система автоматически проверяет версию и блокирует старые версии.",
      "disableSuccess": "Проверка версии клиента отключена",
      "enable": "Включить проверку версии клиента",
      "enableSuccess": "Проверка версии клиента включена",
      "toggleFailed": "Ошибка переключения"
    }
  },
  "common": {
    "cancel": "Отменить",
    "completed": "Завершено",
    "confirm": "Подтвердить",
    "copied": "Ключ скопирован в буфер обмена",
    "copy": "Копировать",
    "copyFailed": "Ошибка копирования",
    "create": "Создать",
    "creating": "Создание...",
    "delete": "Удалить",
    "disabled": "Отключено",
    "edit": "Редактировать",
    "empty": "Результаты не найдены",
    "enabled": "Включено",
    "error": "Неизвестная ошибка",
    "failed": "Ошибка",
    "loading": "Загрузка...",
    "none": "Нет (нет пользователей с этой версией)",
    "refresh": "Обновить",
    "reset": "Сброс",
    "save": "Сохранить",
    "saving": "Сохранение...",
    "submit": "Отправить",
    "success": "Успех",
    "test": "Тестировать",
    "testing": "Тестирование...",
    "unlimited": "Без ограничений",
    "unlimited_desc": "Без ограничений",
    "update": "Обновить",
    "updating": "Обновление..."
  },
  "config": {
    "autoCleanup": "Автоматическая очистка логов",
    "autoCleanupDesc": "Автоматически очищать исторические логи по расписанию для освобождения места в БД.",
    "description": "Управление основными параметрами системы, влияющими на отображение и поведение статистики.",
    "section": {
      "siteParams": {
        "title": "Параметры сайта",
        "description": "Настройка заголовка сайта, валюты отображения и политики отображения статистики на панели."
      },
      "autoCleanup": {
        "title": "Автоматическая очистка логов",
        "description": "Автоматически очищать исторические логи по расписанию для освобождения места в БД."
      }
    },
    "form": {
      "allowGlobalView": "Разрешить просмотр глобального использования",
      "allowGlobalViewDesc": "При отключении обычные пользователи могут видеть только статистику использования своих ключей на панели.",
      "verboseProviderError": "Подробные ошибки провайдеров",
      "verboseProviderErrorDesc": "При включении возвращает подробные сообщения об ошибках при недоступности всех провайдеров (количество провайдеров, причины ограничений и т.д.); при отключении возвращает только простой код ошибки.",
      "cleanupSchedule": "График очистки",
      "cleanupScheduleDesc": "Выбрать расписание автоматической очистки",
      "configUpdated": "Параметры системы обновлены. Страница обновится для применения изменений валюты.",
      "currencyDisplay": "Валюта",
      "currencyDisplayPlaceholder": "Выберите валюту",
      "currencyDisplayDesc": "После изменения все страницы и API будут использовать соответствующий символ валюты (только символ, без конвертации).",
      "keepDays": "Хранить дней",
      "keepDaysDesc": "Очищать логи старше указанного количества дней",
      "saveFailed": "Ошибка сохранения",
      "saveSuccess": "Сохранено успешно",
      "saveError": "Ошибка сохранения",
      "saveSettings": "Сохранить настройки",
      "siteTitle": "Название сайта",
      "siteTitlePlaceholder": "например: Claude Code Hub",
      "siteTitleRequired": "Название сайта не может быть пустым",
      "siteTitleDesc": "Используется для установки заголовка вкладки браузера и имени системы по умолчанию.",
      "enableAutoCleanup": "Включить автоочистку",
      "enableAutoCleanupDesc": "Автоматически очищать исторические логи по расписанию",
      "cleanupRetentionDays": "Хранить дней",
      "cleanupRetentionDaysRequired": "Хранить дней *",
      "cleanupRetentionDaysPlaceholder": "30",
      "cleanupRetentionDaysDesc": "Логи старше этого количества дней будут автоматически очищены (диапазон: 1-365 дней)",
      "cleanupScheduleLabel": "Время выполнения (Cron)",
      "cleanupScheduleRequired": "Время выполнения (Cron) *",
      "cleanupSchedulePlaceholder": "0 2 * * *",
      "cleanupScheduleCronDesc": "Cron-выражение, по умолчанию: 0 2 * * * (2 часа ночи ежедневно)",
      "cleanupScheduleCronExample": "Пример: 0 3 * * 0 (3 часа ночи каждое воскресенье)",
      "cleanupBatchSize": "Размер пакета",
      "cleanupBatchSizeRequired": "Размер пакета *",
      "cleanupBatchSizePlaceholder": "10000",
      "cleanupBatchSizeDesc": "Количество записей для удаления за раз (диапазон: 1000-100000, рекомендуется 10000)",
      "saveConfig": "Сохранить конфигурацию",
      "autoCleanupSaved": "Конфигурация автоочистки сохранена",
      "currencies": {
        "USD": "$ Доллар США (USD)",
        "CNY": "¥ Китайский юань (CNY)",
        "EUR": "€ Евро (EUR)",
        "JPY": "¥ Японская иена (JPY)",
        "GBP": "£ Фунт стерлингов (GBP)",
        "HKD": "HK$ Гонконгский доллар (HKD)",
        "TWD": "NT$ Новый тайваньский доллар (TWD)",
        "KRW": "₩ Южнокорейская вона (KRW)",
        "SGD": "S$ Сингапурский доллар (SGD)"
      },
      "billingModelSource": "Источник модели для тарификации",
      "billingModelSourcePlaceholder": "Выберите источник модели для тарификации",
      "billingModelSourceDesc": "Настройте, какую модель использовать для тарификации при перенаправлении модели. «До перенаправления» использует исходную модель, запрошенную пользователем, «После перенаправления» использует фактически вызванную модель.",
      "billingModelSourceOptions": {
        "original": "До перенаправления (исходная модель)",
        "redirected": "После перенаправления (фактическая модель)"
      }
    },
    "siteSettings": "Параметры сайта",
    "siteSettingsDesc": "Настройка названия сайта, валюты и политики отображения статистики.",
    "title": "Конфигурация"
  },
  "data": {
    "cleanup": {
      "rangeLabel": "Диапазон очистки",
      "range": {
        "7days": "Логи старше 1 недели (7 дней)",
        "30days": "Логи старше 1 месяца (30 дней)",
        "90days": "Логи старше 3 месяцев (90 дней)",
        "180days": "Логи старше 6 месяцев (180 дней)"
      },
      "rangeDescription": {
        "7days": "1 неделю назад",
        "30days": "1 месяц назад",
        "90days": "3 месяца назад",
        "180days": "6 месяцев назад",
        "default": "{days} дней назад"
      },
      "willClean": "Будут очищены все записи логов с {range}",
      "button": "Очистить логи",
      "confirmTitle": "Подтверждение очистки логов",
      "confirmWarning": "Эта операция навсегда удалит все записи логов с {range} и не может быть отменена.",
      "previewLoading": "Подсчет...",
      "previewCount": "Будет удалено {count} записей логов",
      "previewError": "Не удается получить предварительный просмотр",
      "statisticsRetained": "✓ Статистические данные будут сохранены (для анализа трендов)",
      "logsDeleted": "✗ Детали логов будут удалены (содержимое запроса/ответа, информация об ошибках и т.д.)",
      "backupRecommendation": "Рекомендация: Экспортируйте резервную копию базы данных перед очисткой на случай, если потребуется восстановление.",
      "cancel": "Отмена",
      "confirm": "Подтвердить очистку",
      "cleaning": "Очистка...",
      "successMessage": "Успешно очищено {count} записей логов ({batches} пакетов, заняло {duration}с)",
      "failed": "Очистка не удалась",
      "error": "Не удалось очистить логи",
      "descriptionWarning": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда."
    },
    "description": "Управление резервной копией и восстановлением БД с полным импортом/экспортом и очисткой логов.",
    "export": {
      "button": "Экспортировать базу данных",
      "exporting": "Экспорт...",
      "successMessage": "База данных успешно экспортирована!",
      "failed": "Экспорт не удался",
      "error": "Не удалось экспортировать базу данных",
      "descriptionFull": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных. Резервная копия использует формат PostgreSQL custom format, автоматически сжимается и совместима с разными версиями базы данных."
    },
    "guide": {
      "title": "Инструкции и меры предосторожности",
      "items": {
        "cleanup": {
          "title": "Очистка логов",
          "description": "Физически удаляет исторические логи (необратимо). Таблица статистики будет сохранена. Рекомендуется сначала экспортировать резервную копию."
        },
        "format": {
          "title": "Формат резервной копии",
          "description": "Использует PostgreSQL custom format (.dump), автоматически сжимается и совместим с разными версиями БД."
        },
        "overwrite": {
          "title": "Режим перезаписи",
          "description": "Удаляет все существующие данные перед импортом. Лучше всего для полного восстановления."
        },
        "merge": {
          "title": "Режим объединения",
          "description": "Сохраняет существующие данные и пытается вставить из резервной копии. Конфликты первичного ключа могут привести к ошибкам."
        },
        "safety": {
          "title": "Рекомендация безопасности",
          "description": "Перед импортом сначала экспортируйте текущую БД как резервную копию."
        },
        "environment": {
          "title": "Требования окружения",
          "description": "Требует развертывания Docker Compose. Локальная разработка может не поддерживаться."
        }
      }
    },
    "import": {
      "selectFileLabel": "Выбрать файл резервной копии",
      "fileSelected": "Выбрано: {name} ({size} МБ)",
      "fileError": "Пожалуйста, выберите файл резервной копии в формате .dump",
      "noFileSelected": "Сначала выберите файл резервной копии",
      "cleanFirstLabel": "Очистить существующие данные (режим перезаписи)",
      "cleanFirstDescription": "Удалить все существующие данные перед импортом, чтобы база данных точно соответствовала резервной копии. Если не отмечено, будет предпринята попытка объединения данных, но это может не удаться из-за конфликтов первичных ключей.",
      "button": "Импортировать базу данных",
      "importing": "Импорт...",
      "progressTitle": "Прогресс импорта",
      "confirmTitle": "Подтверждение импорта базы данных",
      "confirmOverwrite": "Вы выбрали 'Режим перезаписи', который удалит все существующие данные перед импортом резервной копии.",
      "confirmMerge": "Вы выбрали 'Режим объединения', который попытается импортировать резервную копию, сохраняя существующие данные.",
      "warningOverwrite": "⚠️ Предупреждение: Это действие необратимо, все текущие данные будут навсегда удалены!",
      "warningMerge": "⚠️ Примечание: Импорт может не удаться при наличии конфликтов первичных ключей.",
      "backupFile": "Файл резервной копии:",
      "backupRecommendation": "Рекомендуется экспортировать текущую базу данных в качестве резервной копии перед продолжением.",
      "cancel": "Отмена",
      "confirm": "Подтвердить импорт",
      "successMessage": "Импорт данных завершен!",
      "failedMessage": "Импорт данных не удался, проверьте подробные логи",
      "error": "Не удалось импортировать базу данных",
      "streamError": "Не удается прочитать поток ответа",
      "errorUnknown": "Неизвестная ошибка",
      "descriptionFull": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump)."
    },
    "status": {
      "loading": "Загрузка...",
      "error": "Не удалось получить статус базы данных",
      "retry": "Повторить",
      "connected": "База данных подключена",
      "unavailable": "База данных недоступна",
      "tables": "{count} таблиц"
    },
    "title": "Управление данными",
    "section": {
      "status": {
        "title": "Статус базы данных",
        "description": "Просмотр текущего статуса подключения к базе данных и основной информации."
      },
      "cleanup": {
        "title": "Очистка логов",
        "description": "Очистка исторических данных логов для освобождения дискового пространства базы данных. Примечание: Статистические данные будут сохранены, но детали логов будут удалены навсегда."
      },
      "export": {
        "title": "Экспорт данных",
        "description": "Экспорт полного файла резервной копии базы данных (формат .dump) для миграции или восстановления данных."
      },
      "import": {
        "title": "Импорт данных",
        "description": "Восстановление базы данных из файла резервной копии. Поддерживает файлы резервных копий в формате PostgreSQL custom format (.dump)."
      }
    }
  },
  "errors": {
    "saveSuccess": "Сохранение успешно",
    "saveFailed": "Ошибка сохранения",
    "saveFailed_error": "Не удалось сохранить настройки",
    "addSuccess": "Добавление успешно",
    "addFailed": "Не удалось добавить провайдера",
    "editSuccess": "Обновление успешно",
    "editFailed": "Не удалось обновить провайдера",
    "deleteSuccess": "Удаление успешно",
    "deleteFailed": "Не удалось удалить провайдера",
    "syncSuccess": "Синхронизация успешна",
    "syncFailed": "Ошибка синхронизации",
    "testFailed": "Тест не пройден",
    "testFailedRetry": "Тест не пройден, попробуйте снова",
    "loadFailed": "Не удалось загрузить настройки уведомлений",
    "unknownError": "Во время операции произошло исключение"
  },
  "logs": {
    "description": "Динамическая регулировка уровня логирования для контроля подробности.",
    "subtitle": "Контроль уровня логирования",
    "subtitleDesc": "Изменения вступают в силу немедленно без перезагрузки. Полезно для отладки в производстве.",
    "section": {
      "title": "Контроль уровня логирования",
      "description": "Изменения вступают в силу немедленно без перезапуска сервиса."
    },
    "levels": {
      "fatal": {
        "label": "Fatal",
        "description": "Только критические ошибки"
      },
      "error": {
        "label": "Error",
        "description": "Сообщения об ошибках"
      },
      "warn": {
        "label": "Warn",
        "description": "Предупреждения + Ошибки"
      },
      "info": {
        "label": "Info",
        "description": "Ключевые бизнес-события + Предупреждения + Ошибки (Рекомендуется для продакшена)"
      },
      "debug": {
        "label": "Debug",
        "description": "Отладочная информация + Все уровни (Рекомендуется для разработки)"
      },
      "trace": {
        "label": "Trace",
        "description": "Очень подробная трассировка + Все уровни"
      }
    },
    "form": {
      "currentLevel": "Текущий уровень логирования",
      "selectLevel": "Выбрать уровень логирования",
      "save": "Сохранить параметры",
      "saving": "Сохранение...",
      "success": "Уровень логирования установлен: {level}",
      "failed": "Ошибка установки",
      "failedError": "Ошибка установки уровня логирования",
      "fetchFailed": "Ошибка получения уровня логирования",
      "effectiveImmediately": "Изменения уровня логирования вступают в силу немедленно без перезапуска сервиса.",
      "levelGuideTitle": "Руководство по уровням логирования",
      "levelGuideFatal": "Fatal/Error: Показывать только ошибки, минимальное логирование, подходит для высоконагруженного продакшена",
      "levelGuideWarn": "Warn: Включает предупреждения (ограничение скорости, открытие автомата защиты и т.д.) + Ошибки",
      "levelGuideInfo": "Info (Рекомендуется для продакшена): Показывает ключевые бизнес-события (выбор поставщика, повторное использование сессии, синхронизация цен) + Предупреждения + Ошибки",
      "levelGuideDebug": "Debug (Рекомендуется для разработки): Включает подробную отладочную информацию, подходит для устранения проблем",
      "levelGuideTrace": "Trace: Очень подробная трассировочная информация, включает все детали",
      "changeNotice": "Текущий уровень {current}, после сохранения переключится на {selected}"
    },
    "title": "Управление логами"
  },
  "nav": {
    "apiDocs": "API док.",
    "clientVersions": "Обновления",
    "config": "Конфиг",
    "data": "Данные",
    "errorRules": "Ошибки",
    "feedback": "Отзывы",
    "docs": "Документация",
    "logs": "Логи",
    "notifications": "Уведомления",
    "prices": "Цены",
    "providers": "Поставщики",
    "sensitiveWords": "Фильтры",
    "requestFilters": "Запросы"
  },
  "notifications": {
    "title": "Push-уведомления",
    "description": "Настройка push-уведомлений Webhook",
    "global": {
      "title": "Главный переключатель уведомлений",
      "description": "Включить или отключить все функции push-уведомлений",
      "enable": "Включить push-уведомления"
    },
    "circuitBreaker": {
      "title": "Оповещение о размыкателе цепи",
      "description": "Отправить оповещение немедленно при полном размыкании провайдера",
      "enable": "Включить оповещение о размыкателе цепи",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "test": "Тест подключения"
    },
    "dailyLeaderboard": {
      "title": "Ежедневный рейтинг потребления пользователей",
      "description": "Ежедневная отправка рейтинга топ N пользователей по потреблению",
      "enable": "Включить ежедневный рейтинг",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "time": "Время отправки",
      "timePlaceholder": "09:00",
      "timeError": "Ошибка формата времени, должен быть HH:mm",
      "topN": "Показать топ N",
      "test": "Тест подключения"
    },
    "costAlert": {
      "title": "Оповещение о расходах",
      "description": "Триггер оповещения при превышении порога квоты потребления пользователя/провайдера",
      "enable": "Включить оповещение о расходах",
      "webhook": "Webhook URL",
      "webhookPlaceholder": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send?key=...",
      "webhookTypeWeCom": "WeCom",
      "webhookTypeFeishu": "Feishu",
      "webhookTypeUnknown": "Неизвестная платформа. Используйте URL вебхука WeCom или Feishu",
      "threshold": "Порог оповещения",
      "thresholdLabel": "Порог оповещения: {percent}%",
      "thresholdHelp": "Оповещение при достижении {percent}% квоты",
      "interval": "Интервал проверки (минуты)",
      "test": "Тест подключения"
    },
    "form": {
      "save": "Сохранить настройки",
      "saving": "Сохранение...",
      "loading": "Загрузка...",
      "success": "Настройки уведомлений сохранены и задачи перепланированы",
      "saveFailed": "Ошибка сохранения",
      "saveError": "Не удалось сохранить настройки",
      "loadError": "Не удалось загрузить настройки уведомлений",
      "webhookRequired": "Сначала заполните Webhook URL",
      "testSuccess": "Тестовое сообщение отправлено",
      "testFailed": "Тест не пройден",
      "testFailedRetry": "Тест не пройден, попробуйте снова",
      "testError": "Ошибка тестирования подключения",
      "testNoResult": "Тест пройден, но результат не возвращен"
    }
  },
  "prices": {
    "title": "Прайс-лист",
    "description": "Управление конфигурацией платформы и ценами моделей",
    "section": {
      "title": "Цены моделей",
      "description": "Управление ценами AI моделей"
    },
    "searchPlaceholder": "Поиск по названию модели...",
    "sync": {
      "button": "Синхронизировать цены LiteLLM",
      "syncing": "Синхронизация...",
      "successWithChanges": "Обновление прайс-листа: добавлено {added}, обновлено {updated}, без изменений {unchanged}",
      "successNoChanges": "Прайс-лист актуален, обновление не требуется",
      "failed": "Ошибка синхронизации",
      "failedError": "Ошибка синхронизации: {error}",
      "failedNoResult": "Прайс-лист обновлен но результат не возвращен",
      "noModels": "Цены моделей не найдены",
      "partialFailure": "Частичное обновление выполнено, но {failed} моделей не удалось обновить"
    },
    "table": {
      "modelName": "Название модели",
      "type": "Тип",
      "provider": "Поставщик",
      "inputPrice": "Цена ввода ($/M)",
      "outputPrice": "Цена вывода ($/M)",
      "updatedAt": "Обновлено",
      "typeChat": "Чат",
      "typeImage": "Генерация изображений",
      "typeCompletion": "Дополнение",
      "typeUnknown": "Неизвестно",
      "loading": "Загрузка...",
      "noMatch": "Соответствующие модели не найдены",
      "noDataTitle": "Данные о ценах отсутствуют",
      "noDataHint": "Система имеет встроенный прайс-лист. Используйте кнопки выше для синхронизации."
    },
    "pagination": {
      "showing": "Показано {from}-{to} из {total}",
      "previous": "Назад",
      "next": "Вперёд",
      "perPage": "{size} на странице"
    },
    "stats": {
      "totalModels": "Всего моделей: {count}",
      "searchResults": "Результатов поиска: {count}",
      "lastUpdated": "Последнее обновление: {time}"
    },
    "dialog": {
      "title": "Обновить прайс-лист",
      "description": "Выберите и загрузите JSON файл с данными о ценах моделей",
      "selectFile": "Нажмите для выбора JSON или перетащите сюда",
      "fileSizeLimit": "Размер файла не может превышать 10MB",
      "fileSizeLimitSmall": "Размер файла не превышает 10MB",
      "invalidFileType": "Пожалуйста, выберите файл в формате JSON",
      "fileTooLarge": "Размер файла превышает лимит 10MB",
      "upload": "Загрузить и обновить",
      "uploading": "Загрузка...",
      "updatePriceTable": "Обновить прайс-лист",
      "updating": "Обновление...",
      "selectJson": "Выбрать JSON файл",
      "updateSuccess": "Прайс-лист успешно обновлён, {count} моделей обновлено",
      "updateFailed": "Ошибка обновления",
      "systemHasBuiltIn": "Система имеет встроенный прайс-лист",
      "manualDownload": "Вы также можете скачать вручную",
      "latestPriceTable": "последний прайс-лист",
      "andUploadViaButton": ", и загрузить через кнопку выше",
      "supportedModels": "Поддерживается {count} моделей",
      "results": {
        "title": "Результаты обновления",
        "total": "Всего: {total} моделей",
        "success": "Успешно: {success}",
        "failed": "Ошибок: {failed}",
        "skipped": "Пропущено: {skipped}",
        "details": "Подробности",
        "viewDetails": "Просмотреть подробный журнал"
      }
    }
  },
  "providers": {
    "add": "Добавить поставщика",
    "addFailed": "Ошибка добавления поставщика",
    "addProvider": "Добавить провайдера",
    "addSuccess": "Поставщик добавлен успешно",
    "circuitBroken": "Цепь разомкнута",
    "clone": "Дублировать поставщика",
    "cloneFailed": "Ошибка копирования",
    "confirmDelete": "Вы уверены, что хотите удалить этого поставщика?",
    "confirmDeleteDesc": "Вы уверены, что хотите удалить провайдера \"{name}\"? Это действие не может быть отменено.",
    "confirmDeleteProvider": "Подтвердить удаление провайдера?",
    "confirmDeleteProviderDesc": "Вы уверены, что хотите удалить провайдера \"{name}\"? Это действие не может быть восстановлено.",
    "createProvider": "Добавить провайдера",
    "delete": "Удалить поставщика",
    "deleteFailed": "Ошибка удаления поставщика",
    "deleteSuccess": "Успешно удалено",
    "description": "Настройка поставщиков API и контроль статуса доступности.",
    "disabledStatus": "Отключено",
    "displayCount": "Показано {filtered} / {total} провайдеров",
    "edit": "Редактировать поставщика",
    "editFailed": "Ошибка обновления поставщика",
    "editProvider": "Редактировать провайдера",
    "enabledStatus": "Включено",
    "form": {
      "proxyTest": {
        "fillUrlFirst": "Пожалуйста, сначала заполните URL провайдера",
        "testFailed": "Тест не пройден",
        "testFailedRetry": "Тест не пройден, попробуйте снова",
        "noResult": "Тест успешен, но результат не возвращен",
        "connectionSuccess": "Соединение успешно",
        "connectionFailed": "Соединение не удалось",
        "viaProxy": "（через прокси）",
        "viaDirect": "（прямое）",
        "responseTime": "Время отклика:",
        "statusCode": "Код состояния:",
        "connectionMethod": "Способ соединения:",
        "proxy": "Прокси",
        "direct": "Прямое",
        "errorType": "Тип ошибки:",
        "testing": "Тестирование...",
        "testConnection": "Проверить соединение",
        "timeoutError": "Тайм-аут соединения (5 секунд). Проверьте:\n1. Доступен ли прокси-сервер\n2. Правильность адреса и порта прокси\n3. Правильность данных аутентификации прокси",
        "proxyError": "Ошибка прокси:",
        "networkError": "Сетевая ошибка:"
      },
      "apiTest": {
        "fillUrlFirst": "Пожалуйста, сначала заполните URL провайдера",
        "invalidUrl": "URL провайдера недействителен (только http/https)",
        "fillKeyFirst": "Пожалуйста, сначала заполните API ключ",
        "testFailed": "Тест не пройден",
        "testFailedRetry": "Тест не пройден, попробуйте снова",
        "noResult": "Тест успешен, но результат не возвращен",
        "testSuccess": "Тест модели успешен",
        "testApi": "Тест модели провайдера",
        "testing": "Тестирование...",
        "apiFormat": "Тип провайдера",
        "selectApiFormat": "Выберите тип провайдера для тестирования",
        "apiFormatDesc": "По умолчанию синхронизируется с типом провайдера в конфигурации маршрутизации",
        "formatAnthropicMessages": "Claude (Anthropic Messages API)",
        "formatOpenAIChat": "OpenAI Compatible",
        "formatOpenAIResponses": "Codex (Response API)",
        "testModel": "Тестовая модель",
        "testModelDesc": "Оставьте пустым для использования модели по умолчанию или введите вручную",
        "requestConfig": "Конфигурация запроса",
        "presetConfig": "Пресет",
        "customConfig": "Пользовательский",
        "selectPreset": "Выберите шаблон пресета",
        "presetDesc": "Шаблоны пресетов содержат аутентичные паттерны CLI-запросов для верификации релейного сервиса",
        "customPayloadPlaceholder": "{\"model\": \"...\", \"messages\": [...]}",
        "customPayloadDesc": "Введите пользовательский JSON payload для замены тела запроса по умолчанию",
        "successContains": "Ключевое слово успеха",
        "successContainsPlaceholder": "pong",
        "successContainsDesc": "Ответ должен содержать это ключевое слово для признания успешным",
        "model": "Модель",
        "responseModel": "Модель ответа",
        "responseTime": "Время ответа",
        "usage": "Использование токенов",
        "response": "Предварительный просмотр ответа",
        "error": "Сообщение об ошибке",
        "unknown": "Неизвестно",
        "viewDetails": "Подробнее",
        "copySuccess": "Скопировано в буфер обмена",
        "copyFailed": "Не удалось скопировать",
        "copyResult": "Копировать результат",
        "close": "Закрыть",
        "success": "Успешно",
        "failed": "Не удалось",
        "streamInfo": "Информация о потоковом ответе",
        "chunksReceived": "Полученные чанки",
        "streamFormat": "Формат потока",
        "streamResponse": "Потоковый ответ",
        "chunksCount": "Получено {count} чанков ({format})",
        "truncatedPreview": "Показаны первые {length} символов, скопируйте для просмотра полного текста",
        "truncatedBrief": "Показаны первые {length} символов, нажмите «Подробнее» для полного просмотра",
        "copyFormat": {
          "testResult": "Результат теста",
          "message": "Сообщение",
          "errorDetails": "Детали ошибки"
        },
        "disclaimer": {
          "title": "Внимание",
          "realRequest": "Этот тест отправляет реальный запрос провайдеру и может потреблять небольшую квоту",
          "resultReference": "Результаты могут варьироваться в зависимости от провайдера и служат только для справки",
          "confirmConfig": "Пожалуйста, проверьте URL провайдера, API ключ и конфигурацию модели"
        },
        "resultCard": {
          "status": {
            "green": "Доступен",
            "yellow": "Нестабильно",
            "red": "Недоступен"
          },
          "dialogTitle": "Детали теста провайдера",
          "validation": {
            "title": "Детали трехуровневой валидации",
            "http": {
              "title": "Уровень 1: HTTP статус",
              "statusCode": "Код статуса",
              "passed": "2xx/3xx успех",
              "failed": "4xx/5xx ошибка"
            },
            "latency": {
              "title": "Уровень 2: Порог задержки",
              "actual": "Фактическая задержка",
              "passed": "В пределах порога",
              "failed": "Превышен порог"
            },
            "content": {
              "title": "Уровень 3: Валидация контента",
              "target": "Цель",
              "passed": "Содержит целевую строку",
              "failed": "Цель не найдена"
            },
            "passed": "Пройдено",
            "failed": "Не пройдено",
            "timeout": "Тайм-аут"
          },
          "labels": {
            "http": "HTTP",
            "latency": "Задержка",
            "content": "Контент",
            "model": "Модель",
            "firstByte": "1 байт",
            "totalLatency": "Общая задержка",
            "error": "Ошибка",
            "responsePreview": "Предпросмотр ответа"
          },
          "timing": {
            "title": "Информация о времени",
            "totalLatency": "Общая задержка",
            "firstByte": "1 байт",
            "testedAt": "Время теста"
          },
          "tokenUsage": {
            "title": "Использование токенов",
            "input": "Ввод",
            "output": "Вывод",
            "cacheCreation": "Создание кэша",
            "cacheRead": "Чтение кэша"
          },
          "streamInfo": {
            "title": "Информация о потоковом ответе",
            "isStreaming": "Потоковая передача",
            "chunksCount": "Количество чанков",
            "yes": "Да",
            "no": "Нет"
          },
          "rawResponse": {
            "title": "Тело ответа",
            "hint": "Здесь отображается необработанное содержимое ответа. Вы можете проверить, содержит ли ответ ключевое слово."
          },
          "errorDetails": {
            "title": "Детали ошибки",
            "type": "Тип ошибки"
          },
          "copyText": {
            "status": "Статус",
            "message": "Сообщение",
            "latency": "Задержка",
            "httpStatus": "HTTP статус",
            "model": "Модель",
            "usage": "Использование",
            "inputOutput": "Ввод {input} / Вывод {output} токенов",
            "response": "Ответ",
            "error": "Ошибка",
            "testedAt": "Время теста",
            "validationDetails": "Детали валидации",
            "httpCheck": "Проверка HTTP",
            "latencyCheck": "Проверка задержки",
            "contentCheck": "Проверка контента"
          },
          "judgment": "Решение"
        }
      },
      "urlPreview": {
        "title": "Предварительный просмотр URL",
        "invalidUrl": "Неверный формат URL",
        "invalidUrlDesc": "Пожалуйста, введите действительный HTTP/HTTPS адрес",
        "duplicatePath": "Обнаружен дублирующийся путь",
        "copy": "Копировать",
        "copySuccess": "Скопировано {name} в буфер обмена",
        "copyFailed": "Не удалось скопировать"
      },
      "modelSelect": {
        "allowAllModels": "Разрешить все модели {type}",
        "selectedCount": "Выбрано моделей: {count}",
        "searchPlaceholder": "Поиск по названию модели...",
        "loading": "Загрузка...",
        "notFound": "Модели не найдены",
        "selectAll": "Выбрать все ({count})",
        "clear": "Очистить",
        "manualAdd": "Добавить модель вручную",
        "manualPlaceholder": "Введите название модели (например, gpt-5-turbo)",
        "manualDesc": "Поддержка добавления любого названия модели (не ограничено прайс-листом)",
        "claude": "Claude",
        "openai": "OpenAI",
        "gemini": "Gemini"
      },
      "modelRedirect": {
        "currentRules": "Текущие правила ({count})",
        "addNewRule": "Добавить новое правило",
        "sourceModel": "Запрашиваемая пользователем модель",
        "targetModel": "Фактически перенаправляемая модель",
        "sourcePlaceholder": "Например: claude-sonnet-4-5-20250929",
        "targetPlaceholder": "Например: glm-4.6",
        "add": "Добавить",
        "sourceEmpty": "Название исходной модели не может быть пустым",
        "targetEmpty": "Название целевой модели не может быть пустым",
        "alreadyExists": "Правило перенаправления для модели \"{model}\" уже существует",
        "description": "Перенаправлять запросы моделей от клиента Claude Code (например, claude-sonnet-4.5) к моделям, поддерживаемым вышестоящим провайдером (например, glm-4.6, gemini-pro). Используется для оптимизации затрат или подключения сторонних AI-сервисов.",
        "emptyState": "Пока нет правил перенаправления. После добавления правил система автоматически переписывает названия моделей в запросах."
      },
      "addRedirect": "Добавить переправку",
      "allowAllModels": "✓ Разрешить все модели (рекомендуется)",
      "apiAddress": "Адрес API",
      "apiAddressPlaceholder": "Например: https://open.bigmodel.cn/api/anthropic",
      "apiAddressRequired": "Адрес API *",
      "apiKey": "API ключ",
      "apiKeyCurrent": "Текущий ключ:",
      "apiKeyLeaveEmpty": "（оставьте пустым, чтобы не изменять）",
      "apiKeyLeaveEmptyDesc": "Оставьте пустым, чтобы не изменять ключ",
      "apiKeyOptional": "Оставьте пустым, чтобы оставить текущий ключ",
      "apiKeyPlaceholder": "Введите API ключ",
      "apiKeyRequired": "API ключ *",
      "baseUrl": "Базовый URL",
      "baseUrlPlaceholder": "например: https://open.bigmodel.cn/api/anthropic",
      "baseUrlRequired": "Пожалуйста, сначала заполните URL поставщика",
      "circuitBreakerConfig": "Конфигурация автоматического выключателя",
      "circuitBreakerConfigSummary": "{failureThreshold} сбоев / {openDuration} мин. размыкания / {successThreshold} успехов для восстановления / максимум {maxRetryAttempts} попыток на провайдера",
      "circuitBreakerDesc": "Автоматическое размыкание при последовательных сбоях провайдера для предотвращения влияния на общее качество сервиса",
      "clearSearch": "Очистить поиск",
      "codexInstructions": "Политика инструкций Codex",
      "codexInstructionsAuto": "Автоматически (рекомендуется)",
      "codexInstructionsDesc": "(определяет политику планирования)",
      "codexInstructionsForce": "Принудительно официальные",
      "codexInstructionsKeep": "Сохранить оригинал",
      "codexStrategyAutoDesc": "Передавать instructions клиента, автоматически повторять с официальным prompt при ошибке 400",
      "codexStrategyAutoLabel": "Автоматически (рекомендуется)",
      "codexStrategyConfig": "Стратегия Codex Instructions",
      "codexStrategyConfigAuto": "Автоматически (рекомендуется)",
      "codexStrategyConfigForce": "Принудительно официальные",
      "codexStrategyConfigKeep": "Передавать как есть",
      "codexStrategyDesc": "Управляет обработкой поля instructions в запросах Codex, влияет на совместимость с вышестоящими узлами",
      "codexStrategyForceDesc": "Всегда использовать официальные Codex CLI instructions (около 4000+ символов)",
      "codexStrategyForceLabel": "Принудительно официальные",
      "codexStrategyHint": "Подсказка: некоторые строгие узлы Codex (например, 88code, foxcode) требуют официальные instructions, выберите стратегию \"Автоматически\" или \"Принудительно официальные\"",
      "codexStrategyKeepDesc": "Всегда передавать instructions клиента без автоматического повтора (подходит для гибких узлов)",
      "codexStrategyKeepLabel": "Передавать как есть",
      "codexStrategySelect": "Выбор стратегии",
      "collapseAll": "Свернуть все расширенные настройки",
      "confirmAdd": "Подтвердить добавление",
      "confirmAddPending": "Добавление...",
      "confirmUpdate": "Подтвердить обновление",
      "confirmUpdatePending": "Обновление...",
      "costMultiplier": "Коэф цены",
      "costMultiplierDesc": "например: A (стоимость 1.0x), C (стоимость 0.8x)",
      "costMultiplierLabel": "Коэффициент стоимости",
      "costMultiplierPlaceholder": "1.0",
      "deleteButton": "Удалить",
      "enabled": "Включено",
      "expandAll": "Развернуть все расширенные настройки",
      "failureThreshold": "Порог сбоев (раз)",
      "failureThresholdDesc": "Сколько последовательных сбоев до размыкания",
      "failureThresholdPlaceholder": "5",
      "filterAllProviders": "Все поставщики",
      "filterByType": "Фильтр по типу",
      "filterProvider": "Фильтр типа поставщика",
      "group": "Группа",
      "groupPlaceholder": "например: premium, economy",
      "joinClaudePool": "Присоединиться к пулу планирования Claude",
      "joinClaudePoolDesc": "При включении этот поставщик будет участвовать в балансировке нагрузки вместе с поставщиками типа Claude",
      "joinClaudePoolHelp": "Доступно только при наличии перенаправлений на модели claude-* в конфигурации. При включении этот поставщик также будет участвовать в выборе при запросах моделей claude-*.",
      "leaveEmpty": "Оставьте пустым для неограниченного доступа",
      "limit0Means": "0 означает без ограничений",
      "limit5hLabel": "Лимит расходов за 5 часов (USD)",
      "limitAmount5h": "Лимит расходов за 5 часов (USD)",
      "limitAmount5hDesc": "например: Поставщик B имеет лимит $10, уже потрачено $9.8",
      "limitAmountMonthly": "Месячный лимит расходов (USD)",
      "limitAmountWeekly": "Недельный лимит расходов (USD)",
      "limitConcurrent": "Лимит параллельных сеансов",
      "limitConcurrentDesc": "например: Поставщик C имеет лимит 2, в данный момент 2 активных сеанса",
      "limitConcurrentLabel": "Лимит одновременных сеансов",
      "limitMonthlyLabel": "Месячный лимит расходов (USD)",
      "limitPlaceholder0": "0 означает без ограничений",
      "limitPlaceholderUnlimited": "Оставьте пустым для неограниченного доступа",
      "limitWeeklyLabel": "Недельный лимит расходов (USD)",
      "modelRedirects": "Перенаправление моделей",
      "modelRedirectsAddNew": "Добавить новое правило",
      "modelRedirectsCurrentRules": "Текущие правила ({count})",
      "modelRedirectsDesc": "Переправить запросы Claude к другим поддерживаемым моделям",
      "modelRedirectsEmpty": "Нет правил перенаправления. После добавления правил система автоматически перезапишет имена моделей в запросах.",
      "modelRedirectsExists": "Правило перенаправления для модели \"{model}\" уже существует",
      "modelRedirectsLabel": "Конфигурация перенаправления моделей",
      "modelRedirectsOptional": "(необязательно)",
      "modelRedirectsSourceModel": "Модель запроса пользователя",
      "modelRedirectsSourcePlaceholder": "например: claude-sonnet-4-5-20250929",
      "modelRedirectsSourceRequired": "Имя исходной модели не может быть пустым",
      "modelRedirectsTargetModel": "Фактически перенаправляемая модель",
      "modelRedirectsTargetPlaceholder": "например: glm-4.6",
      "modelRedirectsTargetRequired": "Имя целевой модели не может быть пустым",
      "modelWhitelist": "Белый список моделей",
      "modelWhitelistAllowAll": "Разрешить все модели {type}",
      "modelWhitelistAllowAllClause": "Разрешить все модели Claude",
      "modelWhitelistAllowAllOpenAI": "Разрешить все модели OpenAI",
      "modelWhitelistClear": "Очистить",
      "modelWhitelistDesc": "Ограничить модели, которые может обрабатывать этот поставщик. По умолчанию поставщик может обрабатывать все модели этого типа.",
      "modelWhitelistLabel": "Разрешенные модели",
      "modelWhitelistLoading": "Загрузка...",
      "modelWhitelistManualAdd": "Добавить модель вручную",
      "modelWhitelistManualDesc": "Поддерживает добавление любого имени модели (не ограничено прайс-листом)",
      "modelWhitelistManualPlaceholder": "Введите имя модели (например, gpt-5-turbo)",
      "modelWhitelistNotFound": "Модели не найдены",
      "modelWhitelistSearchPlaceholder": "Поиск по имени модели...",
      "modelWhitelistSelectAll": "Выбрать все ({count})",
      "modelWhitelistSelected": "Выбрано {count} моделей",
      "modelWhitelistSelectedOnly": "Разрешены только выбранные {count} моделей. Запросы других моделей не будут направлены к этому поставщику.",
      "name": {
        "label": "Имя провайдера *",
        "placeholder": "например: Zhipu"
      },
      "namePlaceholder": "Введите имя поставщика",
      "openDuration": "Длительность размыкания (минуты)",
      "openDurationDesc": "Время автоматического перехода в полуоткрытое состояние после размыкания",
      "openDurationPlaceholder": "30",
      "priority": "Приоритет",
      "priorityDesc": "В пределах одного приоритета сортировка по множителю стоимости от низкого к высокому",
      "priorityLabel": "Приоритет",
      "priorityPlaceholder": "0",
      "providerGroupDesc": "Метка группы поставщика. Пользователь может использовать этого поставщика только если его providerGroup совпадает с этим значением. Пример: установка \"premium\" означает использование только пользователями с providerGroup=\"premium\"",
      "providerGroupLabel": "Группа поставщика",
      "providerGroupPlaceholder": "например: premium, economy",
      "providerName": "Имя поставщика",
      "providerNamePlaceholder": "например: Zhipu",
      "providerNameRequired": "Имя поставщика *",
      "providerType": "Тип поставщика",
      "providerTypeDesc": "Выберите тип формата API поставщика.",
      "providerTypeDisabledNote": "Примечание: функции типов Gemini CLI и OpenAI Compatible находятся в разработке и временно недоступны",
      "proxy": "Прокси",
      "proxyAddressFormats": "Поддерживаемые форматы:",
      "proxyAddressLabel": "Адрес прокси",
      "proxyAddressOptional": "(необязательно)",
      "proxyAddressPlaceholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
      "proxyConfig": "Конфигурация прокси",
      "proxyConfigDesc": "Настройка прокси-сервера для улучшения подключения к поставщику (поддерживает HTTP, HTTPS, SOCKS4, SOCKS5)",
      "proxyConfigNone": "Не настроен",
      "proxyConfigSummary": "Прокси настроен",
      "proxyConfigSummaryFallback": " (откат включен)",
      "proxyConfigured": "Прокси настроен",
      "proxyFallback": "Откат при ошибке прокси",
      "proxyFallbackDesc": "Перейти на прямое соединение при ошибке прокси",
      "proxyFallbackLabel": "Откат на прямое соединение при ошибке прокси",
      "proxyNotConfigured": "Не настроен",
      "proxyTestButton": "Проверить соединение",
      "proxyTestDesc": "Тестирование доступа к URL поставщика через настроенный прокси (использует HEAD запрос, не расходует квоту)",
      "proxyTestFailed": "Соединение не удалось",
      "proxyTestFillUrl": "Пожалуйста, сначала заполните URL поставщика",
      "proxyTestLabel": "Тест соединения",
      "proxyTestNetworkError": "Сетевая ошибка: {error}",
      "proxyTestProxyError": "Ошибка прокси: {error}",
      "proxyTestResponseTime": "Время отклика: {time}",
      "proxyTestResultConnectionMethod": "Способ соединения: {via}",
      "proxyTestResultConnectionMethodDirect": "Прямое",
      "proxyTestResultConnectionMethodProxy": "Прокси",
      "proxyTestResultErrorType": "Тип ошибки: {type}",
      "proxyTestResultFailed": "Соединение не удалось",
      "proxyTestResultMessage": "{message}",
      "proxyTestResultResponseTime": "Время отклика: {time}мс",
      "proxyTestResultStatusCode": "Код статуса: {code}",
      "proxyTestResultSuccess": "Соединение успешно {via}",
      "proxyTestStatusCode": "| Код статуса: {code}",
      "proxyTestSuccess": "Соединение успешно",
      "proxyTestTesting": "Тестирование...",
      "proxyTestTimeout": "Тайм-аут соединения (5 секунд). Проверьте:\n1. Доступен ли прокси-сервер\n2. Правильность адреса и порта прокси\n3. Правильность данных аутентификации прокси",
      "proxyTestViaDirect": "（прямое）",
      "proxyTestViaProxy": "（через прокси）",
      "proxyUrl": "Адрес прокси",
      "proxyUrlPlaceholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
      "rateLimitConfig": "Конфигурация ограничения скорости",
      "rateLimitConfigNone": "Без ограничений",
      "rateLimitConfigSummary": "5ч: ${fiveHour}, Неделя: ${weekly}, Месяц: ${monthly}, Одновременно: {concurrent}",
      "remark": "Примечание",
      "remarkPlaceholder": "Необязательно: добавить примечание...",
      "removeRedirect": "Удалить переправку",
      "routingConfig": "Конфигурация маршрутизации",
      "routingConfigNone": "Не настроено",
      "routingConfigSummary": "{models} белый список моделей, {redirects} перенаправлений",
      "scheduleParams": "Параметры планирования",
      "searchClear": "Очистить поиск",
      "searchPlaceholder": "Поиск по имени, URL, примечанию...",
      "selectProviderType": "Выбрать тип поставщика",
      "sort": "Сортировать поставщиков",
      "sortByCost": "По стоимости",
      "sortByCreated": "По дате создания (новое-старое)",
      "sortByName": "По имени (A-Z)",
      "sortByPriority": "По приоритету (высокое-низкое)",
      "sortByWeight": "По весу (высокое-низкое)",
      "sourceModel": "Исходная модель",
      "sourceModelPlaceholder": "например: claude-sonnet-4-5-20250929",
      "sourceModelRequired": "Имя исходной модели не может быть пустым",
      "successThreshold": "Порог восстановления (раз)",
      "successThresholdDesc": "Количество успешных попыток в полуоткрытом состоянии для полного восстановления",
      "successThresholdPlaceholder": "2",
      "targetModel": "Целевая модель",
      "targetModelPlaceholder": "например: glm-4.6",
      "targetModelRequired": "Имя целевой модели не может быть пустым",
      "testProxy": "Проверить соединение",
      "testProxyFailed": "Ошибка тестирования прокси",
      "testProxyFailedError": "Ошибка проверки соединения:",
      "testProxySuccess": "Соединение прокси успешно",
      "validUrlRequired": "Пожалуйста, введите действительный адрес API",
      "websiteUrl": {
        "label": "Сайт провайдера",
        "placeholder": "https://example.com",
        "desc": "Официальный сайт провайдера для быстрого доступа"
      },
      "websiteUrlDesc": "Адрес официального сайта поставщика для быстрого перехода к управлению",
      "websiteUrlInvalid": "Пожалуйста, введите действительный адрес официального сайта поставщика",
      "websiteUrlPlaceholder": "https://example.com",
      "weight": "Вес",
      "weightDesc": "Взвешенная случайная вероятность. В пределах одного приоритета большее число означает выше вероятность выбора.",
      "weightLabel": "Вес",
      "weightPlaceholder": "1",
      "title": {
        "create": "Добавить провайдера",
        "edit": "Редактировать провайдера"
      },
      "url": {
        "label": "Адрес API *",
        "placeholder": "например: https://open.bigmodel.cn/api/anthropic"
      },
      "key": {
        "label": "API ключ",
        "leaveEmpty": "(Оставьте пустым, чтобы не менять)",
        "placeholder": "Введите API ключ",
        "leaveEmptyDesc": "Пустое значение — без изменений",
        "currentKey": "Текущий ключ: {key}"
      },
      "buttons": {
        "expandAll": "Развернуть все расширенные настройки",
        "collapseAll": "Свернуть все расширенные настройки",
        "submit": "Подтвердить добавление",
        "submitting": "Добавление...",
        "update": "Подтвердить обновление",
        "updating": "Обновление...",
        "delete": "Удалить"
      },
      "common": {
        "core": "Основная"
      },
      "sections": {
        "routing": {
          "title": "Маршрутизация",
          "summary": {
            "models": "{count} моделей в белом списке",
            "redirects": "{count} правил перенаправления",
            "none": "Не настроено"
          },
          "providerType": {
            "label": "Тип провайдера",
            "desc": "(определяет политику выбора)",
            "placeholder": "Выберите тип провайдера"
          },
          "providerTypeDesc": "Выберите формат API провайдера.",
          "providerTypeDisabledNote": "Примечание: функции типа OpenAI Compatible находятся в разработке и пока недоступны",
          "modelRedirects": {
            "label": "Перенаправление моделей",
            "optional": "(необязательно)"
          },
          "joinClaudePool": {
            "label": "Включить пул маршрутизации Claude",
            "desc": "При включении провайдер участвует в балансировке нагрузки вместе с провайдерами типа Claude",
            "help": "Доступно только при наличии перенаправления на модели claude-*. При запросе моделей claude-* провайдер также участвует в выборе."
          },
          "unifiedClientId": {
              "label": "Унифицированный идентификатор клиента",
              "desc": "При включении все запросы к апстриму будут использовать один и тот же идентификатор клиента (только для провайдеров Claude / Claude-Auth).",
              "idLabel": "Унифицированный client ID",
              "regenerate": "Сгенерировать заново",
              "help": "ID — это 64-символьная шестнадцатеричная строка. Рекомендуется использовать автоматически сгенерированное значение и не переиспользовать его между разными инсталляциями."
            },
          "preserveClientIp": {
            "label": "Пробрасывать IP клиента",
            "desc": "Передавать x-forwarded-for / x-real-ip в апстрим (может раскрыть реальный IP клиента)",
            "help": "По умолчанию выключено для приватности. Включайте только если апстриму нужен IP пользователя."
          },
          "modelWhitelist": {
            "title": "Список разрешённых моделей",
            "desc": "Ограничьте модели, которые может обслуживать провайдер. По умолчанию доступны все модели данного типа.",
            "label": "Разрешённые модели",
            "optional": "(необязательно)",
            "allowAll": "✓ Разрешить все модели (рекомендуется)",
            "selectedOnly": "Разрешены только выбранные {count} моделей. Другие модели не будут направляться к этому провайдеру.",
            "moreModels": "+{count} ещё"
          },
          "scheduleParams": {
            "title": "Параметры выбора",
            "priority": {
              "label": "Приоритет",
              "placeholder": "0",
              "desc": "Меньше — выше приоритет (0 — наивысший). Система выбирает только из провайдеров с максимальным приоритетом. Рекомендации: основной=0, резерв=1, аварийный=2"
            },
            "weight": {
              "label": "Вес",
              "placeholder": "1",
              "desc": "Взвешенное случайное распределение. В пределах одного приоритета больший вес увеличивает вероятность выбора. Пример 1:2:3 ≈ 16%:33%:50%"
            },
            "costMultiplier": {
              "label": "Множитель стоимости",
              "placeholder": "1.0",
              "desc": "Множитель при расчёте стоимости. Официальный=1.0, дешевле на 20%=0.8, дороже на 20%=1.2 (до 4 знаков после запятой)"
            },
            "group": {
              "label": "Группа провайдера",
              "placeholder": "например: premium, economy",
              "desc": "Метка группы. Пользователь может использовать провайдера только если его providerGroup совпадает. Пример: значение \"premium\" — только для пользователей с providerGroup=\"premium\""
            }
          },
          "context1m": {
            "label": "Контекстное окно 1M",
            "options": {
              "inherit": "Наследовать (следовать клиенту)",
              "forceEnable": "Принудительно включить",
              "disabled": "Отключено"
            },
            "desc": "Настройка поддержки контекстного окна 1M. Применяется только к моделям Sonnet (claude-sonnet-4-5, claude-sonnet-4). При включении применяется многоуровневая тарификация."
          }
        },
        "rateLimit": {
          "title": "Ограничения",
          "summary": {
            "fiveHour": "5ч: ${amount}",
            "weekly": "Неделя: ${amount}",
            "monthly": "Месяц: ${amount}",
            "concurrent": "Параллельно: {count}",
            "none": "Без ограничений"
          },
          "limit5h": {
            "label": "Лимит за 5 часов (USD)",
            "placeholder": "Пусто — без ограничений"
          },
          "limitWeekly": {
            "label": "Недельный лимит (USD)",
            "placeholder": "Пусто — без ограничений"
          },
          "limitMonthly": {
            "label": "Месячный лимит (USD)",
            "placeholder": "Пусто — без ограничений"
          },
          "limitConcurrent": {
            "label": "Лимит параллельных сессий",
            "placeholder": "0 — без ограничений"
          }
        },
        "circuitBreaker": {
          "title": "Предохранитель",
          "summary": "{failureThreshold} неудач / {openDuration} мин. блокировки / {successThreshold} успеха для восстановления / до {maxRetryAttempts} попыток на провайдера",
          "desc": "Автоматическое отключение при серии неудач для защиты качества сервиса",
          "failureThreshold": {
            "label": "Порог неудач",
            "placeholder": "5",
            "desc": "Сколько подряд неудач для срабатывания"
          },
          "openDuration": {
            "label": "Длительность блокировки (мин)",
            "placeholder": "30",
            "desc": "Через сколько перейти в полураскрытое состояние"
          },
          "successThreshold": {
            "label": "Порог восстановления",
            "placeholder": "2",
            "desc": "Сколько успешных запросов в полураскрытом режиме для полного восстановления"
          },
          "maxRetryAttempts": {
            "label": "Максимум попыток на провайдера",
            "placeholder": "2",
            "desc": "Общее число попыток (включая первую) перед переключением на другого провайдера. Оставьте пустым для значения по умолчанию."
          }
        },
        "proxy": {
          "title": "Прокси",
          "summary": {
            "configured": "Прокси настроен",
            "fallback": " (включён откат)",
            "none": "Не настроено"
          },
          "desc": "Настройте прокси для улучшения соединения (поддержка HTTP, HTTPS, SOCKS4, SOCKS5)",
          "url": {
            "label": "URL прокси",
            "optional": "(необязательно)",
            "placeholder": "например: http://proxy.example.com:8080 или socks5://127.0.0.1:1080",
            "formats": "Поддерживаемые форматы:"
          },
          "fallback": {
            "label": "Откат к прямому соединению при сбое прокси",
            "desc": "При включении будет предпринята попытка прямого соединения при сбое прокси"
          },
          "test": {
            "label": "Проверка соединения",
            "desc": "Проверка доступа к URL провайдера через прокси (запрос HEAD, без списания средств)"
          }
        },
        "timeout": {
          "title": "Конфигурация тайм-аута",
          "summary": "1 байт: {streaming}с | поток: {idle}с | не поток: {nonStreaming}с",
          "desc": "Установить время ожидания запроса, 0 означает отключение тайм-аута",
          "streamingFirstByte": {
            "label": "Тайм-аут первого байта потока (секунды)",
            "placeholder": "30",
            "desc": "Тайм-аут первого байта потоковой передачи, диапазон 1-120 секунд, значение по умолчанию 30 секунд",
            "core": "true"
          },
          "streamingIdle": {
            "label": "Тайм-аут простоя потока (секунды)",
            "placeholder": "60",
            "desc": "Тайм-аут простоя потоковой передачи, диапазон 60-600 секунд, введите 0 для отключения (предотвращение застревания)",
            "core": "true"
          },
          "nonStreamingTotal": {
            "label": "Полный тайм-аут непотоковой передачи (секунды)",
            "placeholder": "600",
            "desc": "Полный тайм-аут непотоковой передачи, диапазон 60-1200 секунд, значение по умолчанию 600 секунд (10 минут)",
            "core": "true"
          },
          "disableHint": "Установите 0 для отключения тайм-аута (только для сценариев отката канарейки, не рекомендуется)"
        },
        "codexStrategy": {
          "title": "Политика Codex Instructions",
          "summary": {
            "auto": "Авто (рекомендуется)",
            "force": "Только официальные",
            "keep": "Как есть"
          },
          "desc": "Управление полем instructions в запросах Codex; влияет на совместимость с шлюзами",
          "select": {
            "label": "Выбор стратегии",
            "placeholder": "Выберите стратегию",
            "auto": {
              "label": "Авто (рекомендуется)",
              "desc": "Передавать инструкции клиента; при 400 повтор с официальным промптом"
            },
            "force": {
              "label": "Только официальные",
              "desc": "Всегда использовать официальные инструкции Codex CLI (~4000+ символов)"
            },
            "keep": {
              "label": "Как есть",
              "desc": "Всегда передавать инструкции клиента без автоповторной попытки (для более лояльных прокси)"
            }
          },
          "hint": "Подсказка: некоторым строгим шлюзам Codex (например, 88code, foxcode) требуются официальные инструкции. Выберите «Авто» или «Только официальные»."
        },
        "mcpPassthrough": {
          "title": "Конфигурация сквозной передачи MCP",
          "summary": {
            "none": "Отключено",
            "minimax": "Minimax",
            "glm": "GLM",
            "custom": "Пользовательский (Зарезервировано)"
          },
          "desc": "При включении передаёт вызовы инструментов MCP указанному AI-провайдеру (например, minimax для распознавания изображений, веб-поиска)",
          "select": {
            "label": "Тип сквозной передачи",
            "none": {
              "label": "Отключено",
              "desc": "Не включать сквозную передачу MCP (по умолчанию)"
            },
            "minimax": {
              "label": "Minimax",
              "desc": "Сквозная передача в сервис minimax MCP (поддержка распознавания изображений, веб-поиска и т.д.)"
            },
            "glm": {
              "label": "GLM",
              "desc": "Сквозная передача в сервис GLM MCP (поддержка анализа изображений, видео и т.д.)"
            },
            "custom": {
              "label": "Пользовательский",
              "desc": "Сквозная передача в пользовательский сервис MCP (зарезервировано, не реализовано)"
            },
            "placeholder": "Выберите тип сквозной передачи"
          },
          "hint": "Подсказка: сквозная передача MCP позволяет клиенту Claude Code использовать возможности инструментов, предоставляемых сторонними AI-провайдерами (например, распознавание изображений, веб-поиск)",
          "urlLabel": "URL сквозной передачи MCP",
          "urlPlaceholder": "https://api.minimaxi.com",
          "urlDesc": "Базовый URL сервиса MCP. Оставьте пустым для автоматического извлечения из URL провайдера",
          "urlAuto": "Автоматически извлечено: {url}"
        }
      },
      "providerTypes": {
        "claude": "Claude (Anthropic Messages API)",
        "claudeAuth": "Claude (Anthropic Auth Token)",
        "codex": "Codex (Response API)",
        "gemini": "Gemini (Google Gemini API)",
        "geminiCli": "Gemini CLI",
        "geminiCliDisabled": "",
        "openaiCompatible": "OpenAI Compatible",
        "openaiCompatibleDisabled": " - в разработке"
      },
      "deleteDialog": {
        "title": "Удалить провайдера",
        "description": "Удалить провайдера «{name}»? Это действие необратимо.",
        "cancel": "Отмена",
        "confirm": "Подтвердить удаление"
      },
      "errors": {
        "invalidUrl": "Введите корректный адрес API",
        "invalidWebsiteUrl": "Введите корректный адрес сайта провайдера",
        "addFailed": "Не удалось добавить провайдера",
        "updateFailed": "Не удалось обновить провайдера",
        "deleteFailed": "Не удалось удалить провайдера"
      },
      "success": {
        "created": "Провайдер успешно добавлен",
        "createdDesc": "Провайдер «{name}» добавлен"
      }
    },
    "guide": {
      "after": "После фильтрации:",
      "before": "До фильтрации:",
      "bestPracticesConcurrent": "• Контроль параллелизма: установите количество одновременных сеансов на основе ограничений API поставщика",
      "bestPracticesCost": "• Множитель стоимости: официальный множитель = 1.0, собственный сервис можно установить 0.8-1.2",
      "bestPracticesLimit": "• Настройка лимитов: установите лимиты на 5 часов, 7 дней, 30 дней в соответствии с бюджетом",
      "bestPracticesPriority": "• Настройка приоритета: основные поставщики = 0, резервные = 1-3",
      "bestPracticesTitle": "Рекомендации по лучшим практикам",
      "bestPracticesWeight": "• Настройка веса: установите вес в соответствии с емкостью поставщика (большая емкость = больший вес)",
      "circuitBreaker": "Проверка автоматического выключателя",
      "circuitBreakerOpen": "A отфильтрован, осталось: B, C, D",
      "circuitBreakerRecovery": "A автоматически восстанавливается в полуоткрытое после 60 секунд",
      "circuitBreakerRecovery5h": "Автоматическое восстановление после 5-часового скользящего окна",
      "costOptimize": "2️⃣ Оптимизация стоимости: в пределах одного приоритета поставщики с низким множителем стоимости имеют более высокую вероятность",
      "costSort": "Откат по стоимости",
      "costSortExample": "Все поставщики: A (default), B (premium), C (premium), D (economy)",
      "costSortProb": "Более дешевый C имеет более высокую вероятность выбора",
      "costSortResult": "После сортировки: C (0.8x), A (1.0x)",
      "decision": "Решение:",
      "group": "Фильтрация групп пользователей",
      "groupDesc": "Если пользователь указал группу поставщиков, система приоритизирует выбор из этой группы",
      "groupDowngrade": "Записать предупреждение и выбрать из глобального пула",
      "groupExample": "Пользователь настроил providerGroup = 'premium'",
      "groupFallback": "Если в группе нет доступных поставщиков, откат на всех поставщиков",
      "groupFiltered": "Выбрать только из A и C, B и D отфильтрованы",
      "groupUnavailable": "Все поставщики в группе 'vip' отключены или превышены",
      "health": "Фильтрация здоровья (автоматический выключатель + ограничение)",
      "healthCheck": "Проверить, включен ли B и работоспособен",
      "healthCheckAmountLimit": "Проверить превышение лимитов (5ч, 7д, 30д)",
      "healthCheckAmountLimitExample": "Лимит поставщика B $10 (5ч), потрачено $9.8",
      "healthCheckCircuit": "Поставщик A потерпел неудачу 5 раз, статус: открыт",
      "healthCheckConcurrent": "Проверить количество активных сеансов на лимит",
      "healthCheckConcurrentExample": "Лимит поставщика C 2, активных 2 сеанса",
      "healthFilter": "3️⃣ Фильтрация здоровья: автоматически пропускать поставщиков с размыканием или превышением лимитов",
      "healthFiltered": "B отфильтрован (близко к лимиту), осталось: C, D",
      "healthFiltered2": "C отфильтрован (полный), осталось: D",
      "history": "Проверить историю запросов",
      "historyDesc": "Запрос поставщиков, используемых этим ключом за последние 10 секунд",
      "priority": "Приоритизация по уровням",
      "priorityExample": "4 включенных поставщика с разными приоритетами",
      "priorityFirst": "1️⃣ Приоритет в первую очередь: выбирать только из поставщиков с наивысшим приоритетом (наименьшее число)",
      "priorityResult": "Отфильтровано к приоритету (0): A, C",
      "priorityStep": "Система сначала фильтрует по приоритету, выбирая только из поставщиков с наивысшим приоритетом",
      "randomResult": "В конце выбран C",
      "randomSelect": "Взвешенный случайный",
      "reset": "Ручной сброс автоматического выключателя",
      "resetSuccess": "Автоматический выключатель сброшен",
      "scenario1Desc": "Система сначала фильтрует по приоритету, выбирая только из поставщиков с наивысшим приоритетом",
      "scenario1Step1": "Начальное состояние",
      "scenario1Step1After": "Отфильтрованы поставщики с наивысшим приоритетом (0): A, C",
      "scenario1Step1Before": "Поставщик A (приоритет 0), B (приоритет 1), C (приоритет 0), D (приоритет 2)",
      "scenario1Step1Decision": "Выбирать только из A и C, B и D отфильтрованы",
      "scenario1Step1Desc": "Имеется 4 включенных поставщика с разными приоритетами",
      "scenario1Step2": "Сортировка по стоимости",
      "scenario1Step2After": "После сортировки: C (0.8x), A (1.0x)",
      "scenario1Step2Before": "A (стоимость 1.0x), C (стоимость 0.8x)",
      "scenario1Step2Decision": "C с более низкой стоимостью имеет более высокую вероятность выбора",
      "scenario1Step2Desc": "В пределах одного приоритета сортировка по множителю стоимости от низкого к высокому",
      "scenario1Step3": "Взвешенный случайный выбор",
      "scenario1Step3After": "C имеет вероятность выбора 75%, A имеет вероятность 25%",
      "scenario1Step3Before": "C (вес 3), A (вес 1)",
      "scenario1Step3Decision": "В итоге выбран C",
      "scenario1Step3Desc": "Использование веса для случайного выбора, чем выше вес, тем выше вероятность выбора",
      "scenario1Title": "Выбор по уровням приоритета",
      "scenario2Desc": "Если пользователь указал группу поставщиков, система приоритизирует выбор из этой группы",
      "scenario2Step1": "Проверка группы пользователя",
      "scenario2Step1After": "Отфильтрована группа 'premium': B, C",
      "scenario2Step1Before": "Все поставщики: A (default), B (premium), C (premium), D (economy)",
      "scenario2Step1Decision": "Выбирать только из B и C",
      "scenario2Step1Desc": "Пользователь настроил providerGroup = 'premium'",
      "scenario2Step2": "Откат группировки",
      "scenario2Step2After": "Откат на всех включенных поставщиков: A, B, C, D",
      "scenario2Step2Before": "Все поставщики в группе пользователя 'vip' отключены или превышены",
      "scenario2Step2Decision": "Записать предупреждение и выбрать из глобального пула поставщиков",
      "scenario2Step2Desc": "Если в группе пользователя нет доступных поставщиков, откат на всех поставщиков",
      "scenario2Title": "Фильтрация группы пользователей",
      "scenario3Desc": "Система автоматически фильтрует поставщиков с размыканием или превышением лимитов",
      "scenario3Step1": "Проверка автоматического выключателя",
      "scenario3Step1After": "A отфильтрован, осталось: B, C, D",
      "scenario3Step1Before": "Поставщик A потерпел неудачу 5 раз подряд, состояние выключателя: открыт",
      "scenario3Step1Decision": "A автоматически восстанавливается в полуоткрытое состояние через 60 секунд",
      "scenario3Step1Desc": "После 5 последовательных сбоев выключатель открывается, недоступен в течение 60 секунд",
      "scenario3Step2": "Ограничение по сумме",
      "scenario3Step2After": "B отфильтрован (близко к лимиту), осталось: C, D",
      "scenario3Step2Before": "Лимит поставщика B за 5 часов $10, потрачено $9.8",
      "scenario3Step2Decision": "Автоматическое восстановление после сдвига 5-часового окна",
      "scenario3Step2Desc": "Проверка превышения лимитов расходов за 5 часов, 7 дней, 30 дней",
      "scenario3Step3": "Ограничение одновременных сеансов",
      "scenario3Step3After": "C отфильтрован (полон), осталось: D",
      "scenario3Step3Before": "Лимит одновременных сеансов поставщика C 2, текущее количество активных сеансов: 2",
      "scenario3Step3Decision": "Автоматическое освобождение после истечения сеанса (5 минут)",
      "scenario3Step3Desc": "Проверка превышения настроенного лимита одновременных сеансов",
      "scenario3Title": "Фильтрация здоровья (автоматический выключатель + ограничение)",
      "scenario4Desc": "Последовательные диалоги приоритетно используют одного поставщика для использования кэша контекста Claude",
      "scenario4Step1": "Проверка истории запросов",
      "scenario4Step1After": "Проверить, включен ли B и работоспособен",
      "scenario4Step1Before": "Последний запрос использовал поставщика B",
      "scenario4Step1Decision": "B доступен, повторно использовать напрямую, пропустить случайный выбор",
      "scenario4Step1Desc": "Запрос поставщиков, используемых этим API ключом за последние 10 секунд",
      "scenario4Step2": "Повторное использование недействительно",
      "scenario4Step2After": "Вход в нормальный процесс выбора",
      "scenario4Step2Before": "Последний использованный поставщик B был отключен или разомкнут",
      "scenario4Step2Decision": "Выбрать из других доступных поставщиков",
      "scenario4Step2Desc": "Если последний использованный поставщик недоступен, выполнить повторный выбор",
      "scenario4Title": "Механизм повторного использования сеансов",
      "scenariosTitle": "Интерактивная демонстрация сценариев",
      "session": "Механизм переиспользования сеансов",
      "sessionDesc": "Если последний использованный поставщик недоступен, переходим к переполнению",
      "sessionExample": "Последний запрос использовал поставщика B",
      "sessionExpired": "Сеанс автоматически освобождается после истечения (5 минут)",
      "sessionFallback": "Выбрать из других доступных поставщиков",
      "sessionLastUsed": "B доступен, переиспользуем, пропускаем случайный выбор",
      "sessionReuse": "4️⃣ Повторное использование сеанса: последовательные диалоги повторно используют одного поставщика для экономии затрат на контекст",
      "sessionUnavailable": "Последний использованный поставщик B отключен или замкнут",
      "step": "Шаг",
      "title": "Основные принципы",
      "weight": "Взвешенный случайный выбор по весу",
      "weightCalc": "C имеет вероятность 75%, A имеет вероятность 25%",
      "weightExample": "C (вес 3), A (вес 1)"
    },
    "keyLoading": "Загрузка...",
    "noProviders": "Нет настроенных поставщиков",
    "noProvidersDesc": "Добавьте вашего первого поставщика API",
    "notFound": "Поставщики не найдены",
    "official": "Официальный сайт",
    "resetCircuit": "Автоматический выключатель сброшен",
    "resetCircuitDesc": "Состояние размыкания поставщика \"{name}\" снято",
    "resetCircuitFailed": "Не удалось сбросить автоматический выключатель",
    "scheduling": "Подробное объяснение политики планирования",
    "schedulingDesc": "Понимание того, как работает выбор поставщика: приоритизация, переиспользование сеансов, балансировка нагрузки и отказоустойчивость",
    "searchNoResults": "Поставщики не найдены",
    "searchResults": "Найдено {count} поставщиков",
    "section": {
      "description": "Настройка ограничений по расходам и параллельным сеансам для вышестоящих поставщиков.",
      "leaderboard": "Рейтинг",
      "title": "Поставщики"
    },
    "addProvider": "Добавить",
    "filter": {
      "status": {
        "all": "Все статусы",
        "active": "Активные",
        "inactive": "Неактивные"
      },
      "groups": {
        "label": "Группы:",
        "all": "Все",
        "default": "default"
      }
    },
    "subtitle": "Поставщики",
    "subtitleDesc": "Настройка ограничений по расходам и параллельным сеансам.",
    "title": "Поставщики",
    "todayUsage": "Сегодня",
    "todayUsageCount": "{count} раз",
    "toggleFailed": "Не удалось переключить статус",
    "toggleSuccess": "Поставщик {status}",
    "toggleSuccessDesc": "Статус поставщика \"{name}\" обновлен",
    "updateFailed": "Не удалось обновить поставщика",
    "viewKey": "Просмотреть полный API ключ",
    "viewKeyDesc": "Пожалуйста, храните бережно и не раскрывайте другим",
    "types": {
      "claude": {
        "label": "Claude",
        "description": "Официальный API Anthropic"
      },
      "claudeAuth": {
        "label": "Claude Auth",
        "description": "Служба ретрансляции Claude"
      },
      "codex": {
        "label": "Codex",
        "description": "Codex CLI API"
      },
      "gemini": {
        "label": "Gemini",
        "description": "Google Gemini API"
      },
      "geminiCli": {
        "label": "Gemini CLI",
        "description": "Gemini CLI API"
      },
      "openaiCompatible": {
        "label": "OpenAI Compatible",
        "description": "Совместимый с OpenAI API"
      }
    },
    "list": {
      "priority": "Приоритет",
      "weight": "Вес",
      "costMultiplier": "Коэф цены",
      "todayUsageLabel": "Сегодня",
      "todayUsageCount": "{count} раз(а)",
      "circuitBroken": "Разорвано",
      "officialWebsite": "Официальный",
      "viewFullKey": "Просмотр полного API-ключа",
      "viewFullKeyDesc": "Пожалуйста, храните его в безопасности и не делитесь с другими",
      "keyLoading": "Загрузка...",
      "confirmDeleteTitle": "Подтвердить удаление провайдера?",
      "confirmDeleteMessage": "Вы уверены, что хотите удалить провайдера \"{name}\"? Это действие нельзя отменить.",
      "deleteButton": "Удалить",
      "cancelButton": "Отмена",
      "deleteSuccess": "Успешно удалено",
      "deleteSuccessDesc": "Провайдер \"{name}\" был удален",
      "deleteFailed": "Не удалось удалить",
      "deleteError": "Произошла ошибка во время операции",
      "unknownError": "Неизвестная ошибка",
      "getKeyFailed": "Не удалось получить ключ",
      "keyCopied": "Ключ скопирован в буфер обмена",
      "copyFailed": "Не удалось скопировать",
      "clipboardUnavailable": "Буфер обмена недоступен в этой среде. Скопируйте ключ вручную.",
      "resetCircuitSuccess": "Автоматический выключатель сброшен",
      "resetCircuitSuccessDesc": "Статус автоматического выключателя провайдера \"{name}\" очищен",
      "resetCircuitFailed": "Не удалось сбросить автоматический выключатель",
      "toggleSuccess": "Провайдер {status}",
      "toggleSuccessDesc": "Статус провайдера \"{name}\" обновлен",
      "toggleFailed": "Не удалось переключить",
      "statusEnabled": "включен",
      "statusDisabled": "отключен"
    },
    "inlineEdit": {
      "save": "Сохранить",
      "cancel": "Отмена",
      "saveSuccess": "Успешно сохранено",
      "saveFailed": "Не удалось сохранить",
      "priorityLabel": "Приоритет",
      "weightLabel": "Вес",
      "costMultiplierLabel": "Коэф цены",
      "priorityInvalid": "Введите целое число >= 0",
      "weightInvalid": "Введите целое число от 1 до 100",
      "costMultiplierInvalid": "Введите число не меньше 0"
    },
    "schedulingDialog": {
      "title": "Правила планирования провайдеров",
      "description": "Узнайте, как система интеллектуально выбирает вышестоящих провайдеров для высокой доступности и оптимизации затрат",
      "triggerButton": "Правила",
      "step": "Шаг",
      "before": "До:",
      "after": "После:",
      "decision": "Решение:"
    },
    "sort": {
      "byName": "По имени (A-Z)",
      "byPriority": "По приоритету (выс-низ)",
      "byWeight": "По весу (выс-низ)",
      "byActualPriority": "По фактическому приоритету выбора",
      "byCreatedAt": "По дате создания (нов-стар)",
      "placeholder": "Сортировать провайдеров"
    },
    "search": {
      "placeholder": "Поиск по имени, URL, заметкам...",
      "clear": "Очистить поиск",
      "found": "Найдено {count} совпадающих провайдеров",
      "notFound": "Совпадающие провайдеры не найдены",
      "showing": "Показано {filtered} / {total} провайдеров"
    }
  },
  "sensitiveWords": {
    "add": "Добавить чувствительное слово",
    "addFailed": "Ошибка создания чувствительного слова",
    "addSuccess": "Чувствительное слово создано успешно",
    "cacheStats": "Статистика кэша: Содержит({containsCount}) Точное({exactCount}) Регулярное({regexCount})",
    "confirmDelete": "Вы уверены, что хотите удалить чувствительное слово \"{word}\"?",
    "delete": "Удалить чувствительное слово",
    "deleteFailed": "Ошибка удаления",
    "deleteSuccess": "Чувствительное слово удалено успешно",
    "description": "Настройка фильтрации чувствительных слов для блокирования чувствительного контента.",
    "dialog": {
      "addDescription": "Настройте правила фильтрации чувствительных слов. Совпадающие запросы не будут пересылаться.",
      "addTitle": "Добавить чувствительное слово",
      "creating": "Создание...",
      "descriptionLabel": "Описание",
      "descriptionPlaceholder": "Необязательно: Добавить описание...",
      "editDescription": "Изменить конфигурацию чувствительного слова. Изменения автоматически обновят кэш.",
      "editTitle": "Редактировать чувствительное слово",
      "matchTypeContains": "Частичное совпадение - Блокировать, если текст содержит это слово",
      "matchTypeExact": "Точное совпадение - Блокировать только при точном совпадении",
      "matchTypeLabel": "Тип совпадения *",
      "matchTypeRegex": "Регулярное выражение - Поддержка сложного сопоставления шаблонов",
      "saving": "Сохранение...",
      "wordLabel": "Чувствительное слово *",
      "wordPlaceholder": "Введите чувствительное слово...",
      "wordRequired": "Пожалуйста, введите чувствительное слово"
    },
    "disable": "Чувствительное слово отключено",
    "edit": "Редактировать чувствительное слово",
    "editFailed": "Ошибка обновления чувствительного слова",
    "editSuccess": "Чувствительное слово обновлено успешно",
    "emptyState": "Пока нет чувствительных слов. Нажмите 'Добавить чувствительное слово' в правом верхнем углу для начала настройки.",
    "enable": "Чувствительное слово включено",
    "refreshCache": "Обновить кэш",
    "refreshCacheFailed": "Не удалось обновить кэш",
    "refreshCacheSuccess": "Кэш успешно обновлен, загружено {count} чувствительных слов",
    "section": {
      "description": "Запросы, заблокированные чувствительными словами, не будут пересылаться и не будут тарифицироваться. Поддерживает частичное совпадение, точное совпадение и регулярные выражения.",
      "title": "Список чувствительных слов"
    },
    "table": {
      "actions": "Действия",
      "createdAt": "Создано",
      "description": "Описание",
      "matchType": "Тип совпадения",
      "matchTypeContains": "Частичное",
      "matchTypeExact": "Точное",
      "matchTypeRegex": "Регулярное",
      "status": "Статус",
      "word": "Чувствительное слово"
    },
    "title": "Управление чувствительными словами",
    "toggleFailed": "Ошибка переключения",
    "toggleFailedError": "Ошибка переключения:"
  },
  "requestFilters": {
    "nav": "Фильтры запросов",
    "title": "Фильтры запросов",
    "description": "Настройте удаление/замену заголовков и замену тела перед отправкой вверх по цепочке для маскировки запросов.",
    "add": "Добавить фильтр",
    "addSuccess": "Создано",
    "addFailed": "Не удалось создать",
    "edit": "Редактировать фильтр",
    "editSuccess": "Обновлено",
    "editFailed": "Не удалось обновить",
    "delete": "Удалить фильтр",
    "deleteSuccess": "Удалено",
    "deleteFailed": "Не удалось удалить",
    "enable": "Включено",
    "disable": "Отключено",
    "confirmDelete": "Удалить фильтр \"{name}\"?",
    "empty": "Фильтров пока нет. Добавьте новый.",
    "refreshCache": "Обновить кэш",
    "refreshSuccess": "Кэш обновлен, загружено {count} фильтров",
    "refreshFailed": "Обновление не удалось",
    "dialog": {
      "createTitle": "Добавить фильтр",
      "editTitle": "Редактировать фильтр",
      "name": "Название",
      "scope": "Область",
      "action": "Действие",
      "target": "Поле/путь",
      "replacement": "Значение (опционально)",
      "description": "Описание (опционально)",
      "priority": "Приоритет",
      "matchType": "Тип совпадения",
      "matchTypeContains": "Содержит",
      "matchTypeExact": "Точное",
      "matchTypeRegex": "Регулярное выражение",
      "jsonPathPlaceholder": "например: messages.0.content или data.items[0].token",
      "targetPlaceholder": "Имя заголовка или текст/путь",
      "replacementPlaceholder": "Строка или JSON, пусто — удалить",
      "save": "Сохранить",
      "saving": "Сохранение...",
      "validation": {
        "fieldRequired": "Название и цель обязательны"
      },
      "bindingType": "Применить к",
      "bindingGlobal": "Все провайдеры (глобально)",
      "bindingProviders": "Конкретные провайдеры",
      "bindingGroups": "Группы провайдеров",
      "selectProviders": "Выберите провайдеров...",
      "selectGroups": "Выберите группы...",
      "searchProviders": "Поиск провайдеров...",
      "searchGroups": "Поиск групп...",
      "noProvidersFound": "Провайдеры не найдены",
      "noGroupsFound": "Группы не найдены",
      "providersSelected": "Выбрано провайдеров: {count}",
      "groupsSelected": "Выбрано групп: {count}",
      "loading": "Загрузка...",
      "clear": "Очистить",
      "selectAll": "Выбрать все"
    },
    "table": {
      "name": "Название",
      "scope": "Область",
      "action": "Действие",
      "target": "Цель",
      "replacement": "Значение",
      "priority": "Приоритет",
      "apply": "Область",
      "status": "Статус",
      "createdAt": "Создано",
      "actions": "Действия"
    },
    "scopeLabel": {
      "header": "Header",
      "body": "Body"
    },
    "actionLabel": {
      "remove": "Удалить header",
      "set": "Установить header",
      "json_path": "Замена по JSON пути",
      "text_replace": "Замена текста"
    },
    "applyToAll": "Применяется ко всем запросам",
    "providers": "Провайдеры",
    "groups": "Группы"
  },
  "errorRules": {
    "nav": "Правила ошибок",
    "title": "Управление правилами ошибок",
    "description": "Управление правилами клиентских ошибок, которые не требуют автоматических повторов. После настройки ошибки, соответствующие правилам, будут возвращены пользователям напрямую без повторов и не будут учитываться в пороге срабатывания автоматического выключателя провайдера.",
    "section": {
      "title": "Список правил ошибок"
    },
    "tester": {
      "title": "Тестирование правил ошибок",
      "description": "Введите сообщение об ошибке, чтобы проверить совпадение с настроенными правилами и увидеть итоговый ответ.",
      "inputLabel": "Тестовое сообщение об ошибке",
      "inputPlaceholder": "Введите сообщение об ошибке для проверки...",
      "testButton": "Запустить тест",
      "testing": "Тестирование...",
      "matched": "Совпало с правилом ошибки",
      "notMatched": "Правила не совпали",
      "finalResponse": "Ответ замены",
      "ruleInfo": "Совпавшее правило",
      "noRule": "Совпавших правил нет",
      "category": "Категория",
      "pattern": "Шаблон",
      "matchType": "Тип совпадения",
      "overrideStatusCode": "Код статуса замены",
      "testFailed": "Тест не удался, попробуйте позже",
      "messageRequired": "Введите сообщение об ошибке для проверки",
      "warnings": "Предупреждения конфигурации",
      "statusCodeOnlyOverride": "Заменяется только код статуса, тело ответа будет использовать исходную ошибку"
    },
    "add": "Добавить правило ошибки",
    "addSuccess": "Правило ошибки успешно создано",
    "addFailed": "Не удалось создать правило ошибки",
    "edit": "Редактировать правило ошибки",
    "editSuccess": "Правило ошибки успешно обновлено",
    "editFailed": "Не удалось обновить правило ошибки",
    "delete": "Удалить правило ошибки",
    "deleteSuccess": "Правило ошибки успешно удалено",
    "deleteFailed": "Удаление не удалось",
    "enable": "Правило ошибки включено",
    "disable": "Правило ошибки отключено",
    "toggleFailed": "Переключение не удалось",
    "toggleFailedError": "Переключение не удалось:",
    "refreshCache": "Синхронизировать правила",
    "refreshCacheSuccess": "Правила успешно синхронизированы, загружено {count} правил ошибок",
    "refreshCacheFailed": "Не удалось синхронизировать правила",
    "cacheStats": "Кэшировано: {totalCount} правил",
    "emptyState": "Правил ошибок пока нет. Нажмите 'Добавить правило ошибки' в правом верхнем углу, чтобы начать настройку.",
    "confirmDelete": "Вы уверены, что хотите удалить правило ошибки \"{pattern}\"?",
    "dialog": {
      "addTitle": "Добавить правило ошибки",
      "addDescription": "Настройте шаблоны регулярных выражений для сообщений об ошибках. Совпадающие ошибки будут определены как неповторяемые клиентские ошибки.",
      "editTitle": "Редактировать правило ошибки",
      "editDescription": "Измените конфигурацию правила ошибки. Изменения автоматически обновят кэш.",
      "patternLabel": "Регулярное выражение *",
      "patternPlaceholder": "Введите регулярное выражение...",
      "patternRequired": "Пожалуйста, введите регулярное выражение",
      "patternHint": "Поддерживает синтаксис регулярных выражений JavaScript, например: prompt is too long|invalid.*request",
      "categoryLabel": "Категория правила *",
      "categoryPlaceholder": "Выберите категорию правила",
      "categoryRequired": "Пожалуйста, выберите категорию правила",
      "categoryHint": "Выберите категорию ошибки для классификации и статистики",
      "descriptionLabel": "Описание",
      "descriptionPlaceholder": "Необязательно: Добавить описание...",
      "invalidRegex": "Неверный синтаксис регулярного выражения",
      "regexTester": "Тестер регулярных выражений",
      "testMessageLabel": "Тестовое сообщение",
      "testMessagePlaceholder": "Введите сообщение об ошибке для тестирования...",
      "matchSuccess": "Совпадение найдено",
      "matchFailed": "Совпадение не найдено",
      "invalidPattern": "Недействительное регулярное выражение",
      "matchedText": "Совпавший текст",
      "defaultRuleHint": "Шаблон правила по умолчанию не может быть изменен",
      "enableOverride": "Включить переопределение ошибки",
      "enableOverrideHint": "При включении вы можете настроить ответ об ошибке и код статуса, возвращаемые клиентам. Исходные ошибки по-прежнему записываются в базу данных. В настоящее время поддерживается только формат ошибок Claude API.",
      "overrideResponseLabel": "Ответ замены (JSON)",
      "overrideResponsePlaceholder": "{\n  \"type\": \"error\",\n  \"error\": {\n    \"type\": \"invalid_request_error\",\n    \"message\": \"Ваше пользовательское сообщение\"\n  }\n}",
      "overrideResponseHint": "Оставьте пустым для переопределения только кода статуса.",
      "overrideStatusCodeLabel": "Код статуса замены (Необязательно)",
      "overrideStatusCodePlaceholder": "например, 400",
      "overrideStatusCodeHint": "Оставьте пустым для использования кода статуса upstream. Диапазон: 400-599.",
      "useTemplate": "Шаблон Claude Error",
      "useTemplateConfirm": "Существующее содержимое будет заменено шаблоном. Продолжить?",
      "validJson": "Формат JSON корректен",
      "invalidJson": "Неверный формат JSON",
      "invalidStatusCode": "Код статуса должен быть между 400-599",
      "creating": "Создание...",
      "saving": "Сохранение..."
    },
    "table": {
      "pattern": "Регулярное выражение",
      "category": "Категория правила",
      "description": "Описание",
      "status": "Статус",
      "default": "По умолчанию",
      "isEnabled": "Статус включения",
      "isDefault": "Правило по умолчанию",
      "createdAt": "Дата создания",
      "actions": "Действия"
    },
    "form": {
      "fields": {
        "pattern": "Регулярное выражение",
        "category": "Категория правила",
        "description": "Описание"
      },
      "placeholders": {
        "pattern": "например: prompt is too long",
        "category": "Выбрать категорию",
        "description": "Необязательно: Добавить описание..."
      },
      "labels": {
        "pattern": "Регулярное выражение *",
        "category": "Категория правила *",
        "description": "Описание",
        "isEnabled": "Статус включения"
      }
    },
    "actions": {
      "add": "Добавить",
      "edit": "Редактировать",
      "delete": "Удалить",
      "refresh": "Обновить",
      "test": "Тест",
      "messages": {
        "success": "Операция успешна",
        "error": "Операция не удалась"
      }
    },
    "validation": {
      "patternRequired": "Пожалуйста, введите регулярное выражение",
      "categoryRequired": "Пожалуйста, выберите категорию правила",
      "patternInvalid": "Неверный синтаксис регулярного выражения",
      "redosRisk": "Регулярное выражение имеет риск ReDoS, упростите шаблон",
      "patternTooComplex": "Регулярное выражение слишком сложное"
    },
    "categories": {
      "prompt_limit": "Ограничение длины промпта",
      "content_filter": "Фильтр контента",
      "pdf_limit": "Ограничение страниц PDF",
      "thinking_error": "Ошибка формата Thinking",
      "parameter_error": "Ошибка валидации параметров",
      "invalid_request": "Недопустимый запрос",
      "cache_limit": "Ограничение управления кэшем"
    },
    "regexTester": {
      "title": "Тестер регулярных выражений",
      "testMessage": "Тестовое сообщение",
      "testMessagePlaceholder": "Введите сообщение об ошибке для тестирования...",
      "matchResult": "Результат сопоставления",
      "matched": "Совпало",
      "notMatched": "Не совпало",
      "test": "Тест"
    },
    "defaultRules": {
      "cannotDelete": "Правила по умолчанию не могут быть удалены",
      "cannotDisable": "Рекомендуется сохранить правила по умолчанию включенными"
    }
  },
  "mcpPassthroughConfig": "Конфигурация сквозной передачи MCP",
  "mcpPassthroughConfigNone": "Отключено",
  "mcpPassthroughConfigMinimax": "Minimax",
  "mcpPassthroughConfigGlm": "GLM",
  "mcpPassthroughConfigCustom": "Пользовательский (Зарезервировано)",
  "mcpPassthroughDesc": "При включении передаёт вызовы инструментов MCP указанному AI-провайдеру (например, minimax для распознавания изображений, веб-поиска)",
  "mcpPassthroughSelect": "Тип сквозной передачи",
  "mcpPassthroughNoneLabel": "Отключено",
  "mcpPassthroughNoneDesc": "Не включать сквозную передачу MCP (по умолчанию)",
  "mcpPassthroughMinimaxLabel": "Minimax",
  "mcpPassthroughMinimaxDesc": "Сквозная передача в сервис minimax MCP (поддержка распознавания изображений, веб-поиска и т.д.)",
  "mcpPassthroughGlmLabel": "GLM",
  "mcpPassthroughGlmDesc": "Сквозная передача в сервис GLM MCP (поддержка анализа изображений, видео и т.д.)",
  "mcpPassthroughCustomLabel": "Пользовательский",
  "mcpPassthroughCustomDesc": "Сквозная передача в пользовательский сервис MCP (зарезервировано, не реализовано)",
  "mcpPassthroughHint": "Подсказка: сквозная передача MCP позволяет клиенту Claude Code использовать возможности инструментов, предоставляемых сторонними AI-провайдерами (например, распознавание изображений, веб-поиск)",
  "mcpPassthroughUrlLabel": "URL сквозной передачи MCP",
  "mcpPassthroughUrlPlaceholder": "https://api.minimaxi.com",
  "mcpPassthroughUrlDesc": "Базовый URL сервиса MCP. Оставьте пустым для автоматического извлечения из URL провайдера",
  "mcpPassthroughUrlAuto": "Автоматически извлечено: {url}"
}
