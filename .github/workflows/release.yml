name: Auto Release Pipeline

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Release type'
        required: true
        default: 'patch'
        type: choice
        options:
          - patch
          - minor
          - major
          - beta
          - rc
          - release
      prerelease_number:
        description: 'Beta/RC number (only for beta/rc types)'
        required: false
        default: '1'

permissions:
  contents: write
  packages: write

jobs:
  release-pipeline:
    runs-on: ubuntu-latest
    # è·³è¿‡ç”±GitHub Actionsåˆ›å»ºçš„æäº¤,é¿å…æ­»å¾ªç¯ (ä»…å¯¹pushäº‹ä»¶ç”Ÿæ•ˆ)
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.pusher.name != 'github-actions[bot]' && !contains(github.event.head_commit.message, '[skip ci]'))
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check if version bump is needed
        id: check
        run: |
          # æ£€æµ‹æ˜¯å¦æ˜¯åˆå¹¶æäº¤
          PARENT_COUNT=$(git rev-list --parents -n 1 HEAD | wc -w)
          PARENT_COUNT=$((PARENT_COUNT - 1))
          echo "Parent count: $PARENT_COUNT"

          if [ "$PARENT_COUNT" -gt 1 ]; then
            # åˆå¹¶æäº¤:è·å–åˆå¹¶è¿›æ¥çš„æ‰€æœ‰æ–‡ä»¶å˜æ›´
            echo "Detected merge commit, getting all merged changes"
            # è·å–åˆå¹¶åŸºå‡†ç‚¹
            MERGE_BASE=$(git merge-base HEAD^1 HEAD^2 2>/dev/null || echo "")
            if [ -n "$MERGE_BASE" ]; then
              # è·å–ä»åˆå¹¶åŸºå‡†åˆ° HEAD çš„æ‰€æœ‰å˜æ›´
              CHANGED_FILES=$(git diff --name-only $MERGE_BASE..HEAD)
            else
              # å¦‚æœæ— æ³•è·å–åˆå¹¶åŸºå‡†,ä½¿ç”¨ç¬¬äºŒä¸ªçˆ¶æäº¤
              CHANGED_FILES=$(git diff --name-only HEAD^2..HEAD)
            fi
          else
            # æ™®é€šæäº¤:è·å–ç›¸å¯¹äºä¸Šä¸€ä¸ªæäº¤çš„å˜æ›´
            CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD 2>/dev/null || git diff --name-only $(git rev-list --max-parents=0 HEAD)..HEAD)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # æ£€æŸ¥æ˜¯å¦åªæœ‰æ— å…³æ–‡ä»¶(.md, docs/, .github/ç­‰)
          SIGNIFICANT_CHANGES=false
          while IFS= read -r file; do
            # è·³è¿‡ç©ºè¡Œ
            [ -z "$file" ] && continue

            # æ£€æŸ¥æ˜¯å¦æ˜¯éœ€è¦å¿½ç•¥çš„æ–‡ä»¶
            if [[ ! "$file" =~ \.(md|txt)$ ]] &&
               [[ ! "$file" =~ ^docs/ ]] &&
               [[ ! "$file" =~ ^\.github/workflows/ ]] &&
               [[ "$file" != "VERSION" ]] &&
               [[ "$file" != ".gitignore" ]] &&
               [[ "$file" != "LICENSE" ]]; then
              echo "Found significant change in: $file"
              SIGNIFICANT_CHANGES=true
              break
            fi
          done <<< "$CHANGED_FILES"

          if [ "$SIGNIFICANT_CHANGES" = true ]; then
            echo "Significant changes detected, version bump needed"
            echo "needs_bump=true" >> $GITHUB_OUTPUT
          else
            echo "No significant changes, skipping version bump"
            echo "needs_bump=false" >> $GITHUB_OUTPUT
          fi

      - name: Get current version
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        id: get_version
        run: |
          # è·å–æœ€æ–°çš„tagç‰ˆæœ¬
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          TAG_VERSION=${LATEST_TAG#v}

          # è·å–VERSIONæ–‡ä»¶ä¸­çš„ç‰ˆæœ¬
          FILE_VERSION=$(cat VERSION | tr -d '[:space:]')
          echo "VERSION file: $FILE_VERSION"

          # æ¯”è¾ƒtagç‰ˆæœ¬å’Œæ–‡ä»¶ç‰ˆæœ¬,å–è¾ƒå¤§å€¼
          function version_gt() { test "$(printf '%s\n' "$@" | sort -V | head -n 1)" != "$1"; }

          if version_gt "$FILE_VERSION" "$TAG_VERSION"; then
            VERSION="$FILE_VERSION"
            echo "Using VERSION file: $VERSION (newer than tag)"
          else
            VERSION="$TAG_VERSION"
            echo "Using tag version: $VERSION (newer or equal to file)"
          fi

          echo "Current version: $VERSION"
          echo "current_version=$VERSION" >> $GITHUB_OUTPUT

      - name: Calculate next version
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        id: next_version
        env:
          VERSION_TYPE: ${{ github.event.inputs.version_type || 'patch' }}
          PRERELEASE_NUM: ${{ github.event.inputs.prerelease_number || '1' }}
        run: |
          VERSION="${{ steps.get_version.outputs.current_version }}"

          # ç§»é™¤å¯èƒ½å­˜åœ¨çš„ prerelease åç¼€ä»¥è·å–åŸºç¡€ç‰ˆæœ¬
          BASE_VERSION=$(echo "$VERSION" | sed 's/-.*$//')

          # åˆ†å‰²ç‰ˆæœ¬å·
          IFS='.' read -r -a version_parts <<< "$BASE_VERSION"
          MAJOR="${version_parts[0]:-0}"
          MINOR="${version_parts[1]:-0}"
          PATCH="${version_parts[2]:-0}"

          echo "Base version: $MAJOR.$MINOR.$PATCH"
          echo "Version type: $VERSION_TYPE"

          case "$VERSION_TYPE" in
            major)
              NEW_VERSION="$((MAJOR + 1)).0.0"
              IS_PRERELEASE=false
              ;;
            minor)
              NEW_VERSION="${MAJOR}.$((MINOR + 1)).0"
              IS_PRERELEASE=false
              ;;
            patch)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              IS_PRERELEASE=false
              ;;
            beta)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))-beta.${PRERELEASE_NUM}"
              IS_PRERELEASE=true
              ;;
            rc)
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))-rc.${PRERELEASE_NUM}"
              IS_PRERELEASE=true
              ;;
            release)
              # Convert prerelease to stable release (e.g., 0.4.1-rc.1 -> 0.4.1)
              NEW_VERSION="${BASE_VERSION}"
              IS_PRERELEASE=false
              ;;
            *)
              # é»˜è®¤ patch
              NEW_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
              IS_PRERELEASE=false
              ;;
          esac

          echo "New version: $NEW_VERSION"
          echo "Is prerelease: $IS_PRERELEASE"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "new_tag=v$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT

      - name: Update VERSION file
        if: (steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch') && steps.next_version.outputs.is_prerelease != 'true'
        run: |
          echo "${{ steps.next_version.outputs.new_version }}" > VERSION

      - name: Setup Node.js for formatting
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Setup Bun
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: oven-sh/setup-bun@v2

      - name: Install dependencies and format code
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          bun install
          bun run format

      - name: Commit VERSION and formatted code
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          # é…ç½®git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # æ·»åŠ æ‰€æœ‰æ›´æ”¹ï¼ˆVERSIONæ–‡ä»¶ + æ ¼å¼åŒ–åçš„ä»£ç ï¼‰
          git add -A

          # æ’é™¤ .github/ ç›®å½•çš„æ›´æ”¹ï¼ˆworkflow æ–‡ä»¶ä¸éœ€è¦è‡ªåŠ¨æäº¤ï¼Œä¸”éœ€è¦ç‰¹æ®Šæƒé™ï¼‰
          git restore --staged .github/ 2>/dev/null || true

          # æ£€æŸ¥æ˜¯å¦æœ‰æ›´æ”¹éœ€è¦æäº¤
          if git diff --cached --quiet; then
            echo "No changes to commit"
          else
            # æäº¤æ‰€æœ‰æ›´æ”¹ - æ·»åŠ  [skip ci] ä»¥é¿å…å†æ¬¡è§¦å‘
            git commit -m "chore: sync VERSION file with release ${{ steps.next_version.outputs.new_tag }} [skip ci]"
          fi

      - name: Create and push tag
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          NEW_TAG="${{ steps.next_version.outputs.new_tag }}"
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin HEAD:main "$NEW_TAG"

      - name: Prepare image names
        id: image_names
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        run: |
          GHCR_IMAGE=$(echo "ghcr.io/${{ github.repository_owner }}/claude-code-hub" | tr '[:upper:]' '[:lower:]')

          echo "ghcr_image=${GHCR_IMAGE}" >> "$GITHUB_OUTPUT"

      - name: Create GitHub Release
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.next_version.outputs.new_tag }}
          name: Release ${{ steps.next_version.outputs.new_version }}
          body: |
            ## Docker

            ```bash
            docker pull ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_tag }}
            ${{ steps.next_version.outputs.is_prerelease != 'true' && format('docker pull {0}:latest', steps.image_names.outputs.ghcr_image) || '' }}
            ```

            ---

            Release notes will be auto-generated...
          draft: false
          prerelease: ${{ steps.next_version.outputs.is_prerelease == 'true' }}
          generate_release_notes: false

      # è‡ªæ¸…ç†æ—§çš„tagså’Œreleases(ä¿æŒæœ€è¿‘50ä¸ª) - ä»…æ¸…ç†æ­£å¼ç‰ˆæœ¬
      - name: Cleanup old tags and releases
        if: (steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch') && steps.next_version.outputs.is_prerelease != 'true'
        continue-on-error: true
        env:
          TAGS_TO_KEEP: 50
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ§¹ è‡ªåŠ¨æ¸…ç†æ—§ç‰ˆæœ¬,ä¿æŒæœ€è¿‘ $TAGS_TO_KEEP ä¸ªtag..."

          # è·å–æ‰€æœ‰ç‰ˆæœ¬tagå¹¶æŒ‰ç‰ˆæœ¬å·æ’åº(ä»æ—§åˆ°æ–°)
          echo "æ­£åœ¨è·å–æ‰€æœ‰tags..."
          ALL_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)

          # æ£€æŸ¥æ˜¯å¦è·å–åˆ°tags
          if [ -z "$ALL_TAGS" ]; then
            echo "âš ï¸ æœªæ‰¾åˆ°ä»»ä½•ç‰ˆæœ¬tag"
            exit 0
          fi

          TOTAL_COUNT=$(echo "$ALL_TAGS" | wc -l)

          echo "ğŸ“Š å½“å‰tagç»Ÿè®¡:"
          echo "- æ€»æ•°: $TOTAL_COUNT"
          echo "- é…ç½®ä¿ç•™: $TAGS_TO_KEEP"

          if [ "$TOTAL_COUNT" -gt "$TAGS_TO_KEEP" ]; then
            DELETE_COUNT=$((TOTAL_COUNT - TAGS_TO_KEEP))
            echo "- å°†è¦åˆ é™¤: $DELETE_COUNT ä¸ªæœ€æ—§çš„tag"

            # è·å–è¦åˆ é™¤çš„tags(æœ€è€çš„)
            TAGS_TO_DELETE=$(echo "$ALL_TAGS" | head -n "$DELETE_COUNT")

            # æ˜¾ç¤ºå°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´
            OLDEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | head -1)
            NEWEST_TO_DELETE=$(echo "$TAGS_TO_DELETE" | tail -1)
            echo ""
            echo "ğŸ—‘ï¸ å°†è¦åˆ é™¤çš„ç‰ˆæœ¬èŒƒå›´:"
            echo "- ä»: $OLDEST_TO_DELETE"
            echo "- åˆ°: $NEWEST_TO_DELETE"

            echo ""
            echo "å¼€å§‹æ‰§è¡Œåˆ é™¤..."
            SUCCESS_COUNT=0
            FAIL_COUNT=0

            for tag in $TAGS_TO_DELETE; do
              echo -n "  åˆ é™¤ $tag ... "

              # å…ˆæ£€æŸ¥releaseæ˜¯å¦å­˜åœ¨
              if gh release view "$tag" >/dev/null 2>&1; then
                # Releaseå­˜åœ¨,åˆ é™¤releaseä¼šåŒæ—¶åˆ é™¤tag
                if gh release delete "$tag" --yes --cleanup-tag 2>/dev/null; then
                  echo "(release+tag)"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                else
                  echo "âŒ (releaseåˆ é™¤å¤±è´¥)"
                  FAIL_COUNT=$((FAIL_COUNT + 1))
                fi
              else
                # Releaseä¸å­˜åœ¨,åªåˆ é™¤tag
                if git push origin --delete "$tag" 2>/dev/null; then
                  echo "(ä»…tag)"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                else
                  echo "â­ï¸ (å·²ä¸å­˜åœ¨)"
                  FAIL_COUNT=$((FAIL_COUNT + 1))
                fi
              fi
            done

            echo ""
            echo "ğŸ“Š æ¸…ç†ç»“æœ:"
            echo "- æˆåŠŸåˆ é™¤: $SUCCESS_COUNT"
            echo "- å¤±è´¥/è·³è¿‡: $FAIL_COUNT"

            # é‡æ–°è·å–å¹¶æ˜¾ç¤ºä¿ç•™çš„ç‰ˆæœ¬èŒƒå›´
            echo ""
            echo "æ­£åœ¨éªŒè¯æ¸…ç†ç»“æœ..."
            REMAINING_TAGS=$(git ls-remote --tags origin | grep -E 'refs/tags/v[0-9]+\.[0-9]+\.[0-9]+$' | awk '{print $2}' | sed 's|refs/tags/||' | sort -V)
            REMAINING_COUNT=$(echo "$REMAINING_TAGS" | wc -l)
            OLDEST=$(echo "$REMAINING_TAGS" | head -1)
            NEWEST=$(echo "$REMAINING_TAGS" | tail -1)

            echo "æ¸…ç†å®Œæˆ!"
            echo ""
            echo "ğŸ“Œ å½“å‰ä¿ç•™çš„ç‰ˆæœ¬:"
            echo "- æœ€æ—§ç‰ˆæœ¬: $OLDEST"
            echo "- æœ€æ–°ç‰ˆæœ¬: $NEWEST"
            echo "- ç‰ˆæœ¬æ€»æ•°: $REMAINING_COUNT"

            # éªŒè¯æ˜¯å¦è¾¾åˆ°é¢„æœŸ
            if [ "$REMAINING_COUNT" -le "$TAGS_TO_KEEP" ]; then
              echo "- çŠ¶æ€: ç¬¦åˆé¢„æœŸ(â‰¤$TAGS_TO_KEEP)"
            else
              echo "- çŠ¶æ€: âš ï¸ è¶…å‡ºé¢„æœŸ(æŸäº›tagå¯èƒ½åˆ é™¤å¤±è´¥)"
            fi
          else
            echo "å½“å‰tagæ•°é‡($TOTAL_COUNT)æœªè¶…è¿‡é™åˆ¶($TAGS_TO_KEEP),æ— éœ€æ¸…ç†"
          fi

      # Dockeræ„å»ºæ­¥éª¤
      - name: Set up QEMU
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        if: steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./deploy/Dockerfile
          platforms: linux/amd64,linux/arm64
          push: true
          build-args: |
            APP_VERSION=${{ steps.next_version.outputs.new_version }}
          tags: |
            ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_tag }}
            ${{ steps.next_version.outputs.is_prerelease != 'true' && format('{0}:latest', steps.image_names.outputs.ghcr_image) || '' }}
            ${{ steps.image_names.outputs.ghcr_image }}:${{ steps.next_version.outputs.new_version }}
          labels: |
            org.opencontainers.image.version=${{ steps.next_version.outputs.new_version }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=https://github.com/${{ github.repository }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # åŒæ­¥ main åˆ†æ”¯åˆ° dev åˆ†æ”¯ (rebase dev onto main) - ä»…æ­£å¼ç‰ˆæœ¬è§¦å‘
      - name: Sync main to dev branch
        if: (steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch') && steps.next_version.outputs.is_prerelease != 'true'
        id: sync_dev
        continue-on-error: true
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -e

          echo "=========================================="
          echo "Starting dev branch sync after release..."
          echo "=========================================="

          # é…ç½® git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # ç¡®ä¿åœ¨ main åˆ†æ”¯çš„æœ€æ–°çŠ¶æ€
          git fetch origin main
          git checkout main
          git reset --hard origin/main

          # è·å– dev åˆ†æ”¯
          echo "Fetching dev branch..."
          if ! git fetch origin dev:dev 2>/dev/null; then
            echo "::warning::dev branch not found, skipping sync"
            echo "sync_status=skipped" >> $GITHUB_OUTPUT
            echo "sync_reason=dev branch not found" >> $GITHUB_OUTPUT
            exit 0
          fi

          # æ£€æŸ¥ dev æ˜¯å¦æœ‰é¢†å…ˆäº main çš„ commit
          git checkout dev

          AHEAD_COUNT=$(git rev-list --count main..dev)
          BEHIND_COUNT=$(git rev-list --count dev..main)

          echo "Dev branch status:"
          echo "  - Ahead of main: $AHEAD_COUNT commits"
          echo "  - Behind main: $BEHIND_COUNT commits"

          # å¦‚æœ dev æ²¡æœ‰è½åäº mainï¼Œè·³è¿‡åŒæ­¥
          if [ "$BEHIND_COUNT" -eq 0 ]; then
            echo "::notice::dev branch is already up to date with main"
            echo "sync_status=skipped" >> $GITHUB_OUTPUT
            echo "sync_reason=already up to date" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo ""
          echo "Attempting to rebase dev onto main..."
          echo "This will preserve $AHEAD_COUNT commits from dev"

          # å°è¯• rebase
          if git rebase main; then
            echo "Rebase successful!"

            # ä½¿ç”¨ --force-with-lease å®‰å…¨æ¨é€
            echo "Pushing rebased dev branch..."
            if git push origin dev --force-with-lease; then
              echo "::notice::Successfully synced main to dev branch (rebased $AHEAD_COUNT commits)"
              echo "sync_status=success" >> $GITHUB_OUTPUT
              echo "ahead_count=$AHEAD_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::error::Failed to push rebased dev branch"
              echo "sync_status=push_failed" >> $GITHUB_OUTPUT
              echo "sync_reason=push failed, possibly due to concurrent changes" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "::warning::Rebase failed due to conflicts, will trigger autofix"
            git rebase --abort
            echo "sync_status=conflict" >> $GITHUB_OUTPUT
            echo "sync_reason=merge conflicts detected" >> $GITHUB_OUTPUT
            exit 1
          fi

      # å¦‚æœåŒæ­¥å¤±è´¥(å†²çª)ï¼Œè§¦å‘ autofix workflow
      - name: Trigger autofix for sync conflicts
        if: (steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch') && steps.sync_dev.outputs.sync_status == 'conflict'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          echo "Triggering Claude CI Auto-Fix workflow for dev sync..."

          # ä½¿ç”¨ workflow æ–‡ä»¶åè€Œéåç§°ï¼Œé¿å…é‡å‘½ååè§¦å‘å¤±è´¥
          if gh workflow run claude-ci-autofix.yml \
              --field task_type=sync-dev \
              --field target_branch=dev \
              --field source_branch=main \
              --field release_tag=${{ steps.next_version.outputs.new_tag }}; then
            echo "::notice::Autofix workflow triggered to resolve conflicts"
          else
            echo "::error::Failed to trigger autofix workflow. Manual intervention required."
            echo "::error::Please run: gh workflow run claude-ci-autofix.yml --field task_type=sync-dev --field target_branch=dev --field source_branch=main"
            exit 1
          fi

      # åŒæ­¥ç»“æœæ±‡æ€» - ä»…æ­£å¼ç‰ˆæœ¬æ˜¾ç¤º
      - name: Sync summary
        if: (steps.check.outputs.needs_bump == 'true' || github.event_name == 'workflow_dispatch') && steps.next_version.outputs.is_prerelease != 'true' && always()
        run: |
          echo "=========================================="
          echo "Dev Branch Sync Summary"
          echo "=========================================="

          SYNC_STATUS="${{ steps.sync_dev.outputs.sync_status }}"
          SYNC_REASON="${{ steps.sync_dev.outputs.sync_reason }}"
          AHEAD_COUNT="${{ steps.sync_dev.outputs.ahead_count }}"

          case "$SYNC_STATUS" in
            "success")
              echo "Status: SUCCESS"
              echo "Preserved $AHEAD_COUNT commits from dev branch"
              ;;
            "skipped")
              echo "Status: SKIPPED"
              echo "Reason: $SYNC_REASON"
              ;;
            "conflict")
              echo "Status: CONFLICT - Autofix triggered"
              echo "Reason: $SYNC_REASON"
              echo "The Claude CI Auto-Fix workflow has been triggered to resolve conflicts"
              ;;
            "push_failed")
              echo "Status: PUSH FAILED"
              echo "Reason: $SYNC_REASON"
              echo "Manual intervention may be required"
              ;;
            *)
              echo "Status: UNKNOWN ($SYNC_STATUS)"
              ;;
          esac

          echo "=========================================="
